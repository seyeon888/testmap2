<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자전거 대여소 지도</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    
    <!-- Leaflet MarkerCluster CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"
          crossorigin=""/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"
          crossorigin=""/>
    
    <!-- Custom CSS -->
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="map"></div>

    <!-- 통합 정보 패널 -->
    <div id="info-panel">
        <div class="info-panel-content">
            <!-- 마커 옵션 섹션 -->
            <div class="info-section">
                <div class="section-header">
                    <h4>마커 옵션</h4>
                </div>
                <div class="section-content">
                    <div class="option-group">
                        <div class="district-header" id="district-filter-header" style="cursor: pointer; user-select: none;">
                            <span>구별 필터</span>
                            <span class="district-toggle-icon" style="float: right; margin-left: 8px;">▶</span>
                        </div>
                        <div id="district-filters" class="district-filters" style="display: none;"></div>
                    </div>
                    <div class="option-group">
                        <label style="display: flex; align-items: center; cursor: pointer; padding: 8px 0;">
                            <input type="checkbox" id="show-usage-view" style="margin-right: 8px;">
                            <span>사용량 보기</span>
                        </label>
                    </div>
                </div>
            </div>

            <!-- 대여소 정보 섹션 -->
            <div class="info-section">
                <div class="section-header">
                    <h4>대여소 정보</h4>
                </div>
                <div id="station-info-content" class="section-content">
                    <div class="station-info-placeholder">마커를 클릭하거나 사용량 영역에 마우스를 올리면 정보가 표시됩니다.</div>
                </div>
            </div>

            <!-- 경로 정보 섹션 -->
            <div class="info-section">
                <div class="section-header">
                    <h4>경로 정보</h4>
                </div>
                <div id="route-info-content" class="section-content">
                    <div class="route-info-placeholder">경로를 계산하면 정보가 표시됩니다.</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    
    <!-- Leaflet MarkerCluster JS -->
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"
            crossorigin=""></script>
    
    <!-- Turf.js (GeoJSON 병합 및 단순화 용도) -->
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"
            crossorigin="anonymous"></script>
    
    <script>
        /* ============================================
           API 키 및 설정 변수
           ============================================ */
        
        // Google Maps API 키 설정 (선택사항)
        // Google Maps를 사용하려면 아래 주석을 해제하고 YOUR_API_KEY를 실제 키로 변경하세요
        // var GOOGLE_MAPS_API_KEY = 'YOUR_API_KEY';
        
        // GraphHopper API 키 설정 (선택사항)
        // GraphHopper는 자전거 도로와 도보 경로를 더 정확하게 반영합니다
        // 무료 API 키는 https://www.graphhopper.com/api/ 에서 발급받을 수 있습니다
        // var GRAPHHOPPER_API_KEY = 'YOUR_API_KEY';
        
        // 서울시 공공자전거 대여소 사용 정보 API 키
        var SEOUL_BIKE_API_KEY = '4c6561716e746f7439376d6e4e6267';
        
        // CORS 프록시 설정 (HTTPS 페이지에서 HTTP API 호출 시 필요)
        // 공개 프록시 서비스를 사용하거나, 자신의 프록시 서버를 설정할 수 있습니다
        var USE_CORS_PROXY = true; // HTTPS 환경에서는 true로 설정
        
        // 사용 가능한 프록시 옵션 (여러 프록시를 순차적으로 시도)
        // 더 안정적인 프록시를 우선순위로 배치
        var CORS_PROXY_OPTIONS = [
            'https://api.codetabs.com/v1/proxy?quest=',
            'https://corsproxy.io/?',
            'https://cors-anywhere.herokuapp.com/'
        ];
        var currentProxyIndex = 0; // 현재 사용 중인 프록시 인덱스
        var proxyFailures = {}; // 프록시별 실패 횟수 추적
        
        /* ============================================
           API 유틸리티 함수
           ============================================ */
        
        // API URL 생성 함수 (프록시 사용 여부에 따라 자동 처리)
        // path: API 경로 (예: '/json/bikeList/1/1000')
        // 반환: 프록시가 필요한 경우 프록시 URL, 아니면 원본 URL
        function getApiUrl(path) {
            var baseUrl = 'http://openapi.seoul.go.kr:8088/' + SEOUL_BIKE_API_KEY + path;
            // HTTPS 페이지에서 실행 중이면 프록시 사용
            var isHttps = window.location.protocol === 'https:' || 
                         window.location.hostname.includes('github.io') ||
                         window.location.hostname.includes('github.com');
            
            if (USE_CORS_PROXY && isHttps) {
                var proxyUrl = CORS_PROXY_OPTIONS[currentProxyIndex] + encodeURIComponent(baseUrl);
                // 로그 최소화 (성능 향상)
                return proxyUrl;
            }
            return baseUrl;
        }
        
        /* 프록시 실패 시 다음 프록시로 전환하는 함수
           모든 프록시를 시도한 경우 처음부터 다시 시작 */
        function switchToNextProxy() {
            if (currentProxyIndex < CORS_PROXY_OPTIONS.length - 1) {
                var oldProxy = CORS_PROXY_OPTIONS[currentProxyIndex];
                proxyFailures[oldProxy] = (proxyFailures[oldProxy] || 0) + 1;
                currentProxyIndex++;
                console.warn('프록시 실패:', oldProxy, '-> 다음 프록시로 전환:', CORS_PROXY_OPTIONS[currentProxyIndex]);
            } else {
                console.error('모든 프록시를 시도했지만 실패했습니다. 페이지를 새로고침해주세요.');
                // 모든 프록시 실패 시 처음부터 다시 시도
                currentProxyIndex = 0;
            }
        }
        
        /* 타임아웃이 포함된 fetch 래퍼 함수
           url: 요청할 URL
           timeout: 타임아웃 시간 (밀리초), 기본값 6000ms
           반환: Promise<Response> */
        function fetchWithTimeout(url, timeout) {
            timeout = timeout || 6000; // 기본 6초 타임아웃 (더 빠른 실패 처리)
            return Promise.race([
                fetch(url, {
                    method: 'GET',
                    mode: 'cors',
                    cache: 'no-cache',
                    headers: {
                        'Accept': 'application/json'
                    }
                }),
                new Promise(function(_, reject) {
                    setTimeout(function() {
                        reject(new Error('요청 시간 초과 (타임아웃: ' + timeout + 'ms)'));
                    }, timeout);
                })
            ]);
        }
        
        // 재시도 로직이 포함된 fetch 함수 (프록시 실패 시 자동 전환)
        function fetchWithRetry(url, retries, delay, originalPath) {
            retries = retries || 1; // 재시도 횟수 최소화 (2 -> 1)
            delay = delay || 300; // 재시도 딜레이 최소화 (500ms -> 300ms)
            originalPath = originalPath || null;
            
            return fetchWithTimeout(url, 6000) // 6초 타임아웃
            .then(function(response) {
                if (!response.ok) {
                    // 5xx 오류나 CORS 관련 오류인 경우 프록시 전환 시도
                    if ((response.status >= 500 || response.status === 0) && originalPath && USE_CORS_PROXY) {
                        switchToNextProxy();
                        var newUrl = getApiUrl(originalPath);
                        if (newUrl !== url) {
                            console.log('프록시 전환 후 재시도:', newUrl.substring(0, 80) + '...');
                            return fetchWithRetry(newUrl, retries, delay, originalPath);
                        }
                    }
                    throw new Error('HTTP ' + response.status + ': ' + response.statusText);
                }
                return response.json();
            })
            .catch(function(error) {
                var errorMsg = error.message || error.toString();
                // CORS 오류나 네트워크 오류인 경우 프록시 전환 시도 (재시도 전에 먼저 시도)
                if ((errorMsg.includes('CORS') || errorMsg.includes('Failed to fetch') || errorMsg.includes('NetworkError') || errorMsg.includes('ERR_')) 
                    && originalPath && USE_CORS_PROXY) {
                    // 현재 프록시가 실패했고 다른 프록시가 있으면 전환
                    if (currentProxyIndex < CORS_PROXY_OPTIONS.length - 1) {
                        switchToNextProxy();
                        var newUrl = getApiUrl(originalPath);
                        if (newUrl !== url) {
                            console.log('프록시 전환 후 즉시 재시도:', newUrl.substring(0, 80) + '...');
                            // 프록시 전환 시 재시도 횟수를 리셋하여 새 프록시로 다시 시도
                            return fetchWithRetry(newUrl, 1, 300, originalPath);
                        }
                    }
                }
                
                // 프록시 전환 실패 시 일반 재시도 (로그 제거로 성능 향상)
                if (retries > 0) {
                    return new Promise(function(resolve) {
                        setTimeout(function() {
                            resolve(fetchWithRetry(url, retries - 1, delay * 1.5, originalPath)); // 지수 백오프 완화 (2 -> 1.5)
                        }, delay);
                    });
                }
                throw error;
            });
        }
        
        // Google Maps 스타일 정의
        var mapStyle = [
            {
                "featureType": "all",
                "elementType": "geometry.fill",
                "stylers": [
                    {
                        "weight": "2.00"
                    }
                ]
            },
            {
                "featureType": "all",
                "elementType": "geometry.stroke",
                "stylers": [
                    {
                        "color": "#9c9c9c"
                    }
                ]
            },
            {
                "featureType": "all",
                "elementType": "labels.text",
                "stylers": [
                    {
                        "visibility": "on"
                    }
                ]
            },
            {
                "featureType": "landscape",
                "elementType": "all",
                "stylers": [
                    {
                        "color": "#000000"
                    }
                ]
            },
            {
                "featureType": "landscape",
                "elementType": "geometry.fill",
                "stylers": [
                    {
                        "color": "#000000"
                    }
                ]
            },
            {
                "featureType": "landscape.man_made",
                "elementType": "geometry.fill",
                "stylers": [
                    {
                        "color": "#000000"
                    }
                ]
            },
            {
                "featureType": "poi",
                "elementType": "all",
                "stylers": [
                    {
                        "visibility": "off"
                    }
                ]
            },
            {
                "featureType": "road",
                "elementType": "all",
                "stylers": [
                    {
                        "saturation": -100
                    },
                    {
                        "lightness": 45
                    }
                ]
            },
            {
                "featureType": "road",
                "elementType": "geometry.fill",
                "stylers": [
                    {
                        "color": "#eeeeee"
                    }
                ]
            },
            {
                "featureType": "road",
                "elementType": "labels.text.fill",
                "stylers": [
                    {
                        "color": "#7b7b7b"
                    }
                ]
            },
            {
                "featureType": "road",
                "elementType": "labels.text.stroke",
                "stylers": [
                    {
                        "color": "#ffffff"
                    }
                ]
            },
            {
                "featureType": "road.highway",
                "elementType": "all",
                "stylers": [
                    {
                        "visibility": "simplified"
                    }
                ]
            },
            {
                "featureType": "road.arterial",
                "elementType": "labels.icon",
                "stylers": [
                    {
                        "visibility": "off"
                    }
                ]
            },
            {
                "featureType": "transit",
                "elementType": "all",
                "stylers": [
                    {
                        "visibility": "off"
                    }
                ]
            },
            {
                "featureType": "water",
                "elementType": "all",
                "stylers": [
                    {
                        "color": "#46bcec"
                    },
                    {
                        "visibility": "on"
                    }
                ]
            },
            {
                "featureType": "water",
                "elementType": "geometry.fill",
                "stylers": [
                    {
                        "color": "#c8d7d4"
                    }
                ]
            },
            {
                "featureType": "water",
                "elementType": "labels.text.fill",
                "stylers": [
                    {
                        "color": "#070707"
                    }
                ]
            },
            {
                "featureType": "water",
                "elementType": "labels.text.stroke",
                "stylers": [
                    {
                        "color": "#ffffff"
                    }
                ]
            }
        ];

        // 서울 경계 설정 (대략적인 남서/북동 모서리)
        var seoulBounds = L.latLngBounds(
            [37.413294, 126.734086],
            [37.715133, 127.269311]
        );

        // 지도 초기화 (서울 중심, 서울 경계로 제한)
        var map = L.map('map', {
            minZoom: 10,
            maxZoom: 40,
            zoomControl: true,
            preferCanvas: true
        }).fitBounds(seoulBounds);
        
        // 마커 클러스터 그룹 변수
        var markerClusterGroup = null; // 레거시 호환용
        var clusterGroupsByDistrict = {}; // 구별 클러스터 그룹 저장
        var seoulBoundaryLayer = null;
        var seoulBoundaryPolygon = null;
        var seoulMaskLayer = null;
        var baseTileLayer = null;
        var seoulBoundaryGeoJsonUrl = 'https://raw.githubusercontent.com/codeforamerica/click_that_hood/master/public/data/seoul.geojson';
        var clusterOnlyMaxZoom = 16; // 해당 줌 이하에서는 항상 클러스터로 표시
        var allMarkers = []; // 모든 마커 저장 (필터링용)
        var markersByDistrict = {}; // 구별 마커 저장
        var routeLayer = null; // 경로 표시 레이어
        var routeBikeMarker = null; // 경로를 따라 이동하는 자전거 마커
        var routeAnimationId = null; // 애니메이션 ID (중지용)
        var routeCoordinates = []; // 경로 좌표 배열
        var currentRouteIndex = 0; // 현재 경로 인덱스
        var startMarker = null; // 출발지 마커
        var endMarker = null; // 도착지 마커
        var startLocation = null; // 출발지 좌표
        var endLocation = null; // 도착지 좌표
        var districtFeatures = {}; // 구별 GeoJSON feature 저장
        var hoverHighlightLayer = null; // 호버 하이라이트 레이어
        var bikeStationMarkers = []; // 자전거 대여소 마커 배열
        var bikeStationMarkerGroup = null; // 자전거 대여소 마커 그룹
        var bikeStationCircles = []; // 자전거 대여소 주변 색상 영역 배열
        var allBikeStationData = []; // 모든 자전거 대여소 데이터 저장
        var bikeStationCache = {}; // 지역별 필터링 결과 캐시
        var isDataLoaded = false; // 전체 데이터 로드 여부

        // 마스크용 커스텀 pane (타일 위, 경계선 아래)
        map.createPane('maskPane');
        map.getPane('maskPane').style.zIndex = 300;
        map.getPane('maskPane').style.pointerEvents = 'none';

        // 서울 시군구 이름 목록
        var seoulDistricts = [
            '강남구','강동구','강북구','강서구','관악구','광진구','구로구','금천구','노원구',
            '도봉구','동대문구','동작구','마포구','서대문구','서초구','성동구','성북구','송파구',
            '양천구','영등포구','용산구','은평구','종로구','중구','중랑구'
        ];
        var normalizedAllowedDistricts = seoulDistricts.map(normalizeDistrictName);

        // 맞춤형 마커 아이콘 (자전거 핀 형태)
        var bikeMarkerIcon = L.divIcon({
            className: '',
            html: '<div class="bike-marker"><div class="bike-marker__inner"></div></div>',
            iconSize: [34, 44],
            iconAnchor: [17, 42],
            popupAnchor: [0, -36],
            tooltipAnchor: [0, -30]
        });
        
        // 지도가 로드된 후 데이터 로드
        map.whenReady(function() {
            console.log('지도 로드 완료');
            loadSeoulBoundary()
                .then(function() {
                    loadMarkers();
                })
                .catch(function(error) {
                    console.error('경계 데이터를 불러오지 못했습니다. 그래도 데이터를 로드합니다.', error);
            loadMarkers();
                });
        });
        
        function loadSeoulBoundary() {
            return fetch(seoulBoundaryGeoJsonUrl)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('서울 경계 데이터를 불러오지 못했습니다: ' + response.status);
                    }
                    return response.json();
                })
                .then(function(geojson) {
                    if (seoulBoundaryLayer) {
                        map.removeLayer(seoulBoundaryLayer);
                        seoulBoundaryLayer = null;
                    }
                    var filteredGeojson = filterGeojsonByDistricts(geojson, normalizedAllowedDistricts);
                    var aggregatedGeojson = aggregateDistrictBoundaries(filteredGeojson, normalizedAllowedDistricts);
                    var boundarySource = (aggregatedGeojson && aggregatedGeojson.features && aggregatedGeojson.features.length) ? aggregatedGeojson : filteredGeojson;

                    var mergedBoundary = mergeFeaturesForMask(boundarySource);
                    seoulBoundaryPolygon = (mergedBoundary && mergedBoundary.features && mergedBoundary.features[0]) ? mergedBoundary.features[0] : null;

                    // 구역별 feature 저장
                    districtFeatures = {};
                    if (boundarySource && boundarySource.features) {
                        boundarySource.features.forEach(function(feature) {
                            var districtName = extractDistrictName(feature, normalizedAllowedDistricts);
                            if (districtName) {
                                districtFeatures[districtName] = feature;
                            }
                        });
                    }

                    // 경계 레이어용 pane 생성 (마스크 위에 표시)
                    if (!map.getPane('boundaryPane')) {
                        map.createPane('boundaryPane');
                        map.getPane('boundaryPane').style.zIndex = 400;
                    }
                    
                    seoulBoundaryLayer = L.geoJSON(boundarySource, {
                        pane: 'boundaryPane',
                        style: function(feature) {
                            return {
                                color: '#A8F368', // 연두색
                                weight: 2,
                                opacity: 0.9,
                                fillOpacity: 0, // 기본 투명도 0
                                fillColor: '#A8F368', // 연두색
                                interactive: true
                            };
                        },
                        onEachFeature: function(feature, layer) {
                            var districtName = extractDistrictName(feature, normalizedAllowedDistricts);
                            if (districtName) {
                                // 상호작용 명시적으로 활성화
                                layer.options.interactive = true;
                                
                                // 기본 스타일 저장
                                var defaultStyle = {
                                    fillOpacity: 0,
                                    fillColor: '#A8F368', // 연두색
                                    weight: 2,
                                    color: '#A8F368' // 연두색
                                };
                                
                                // 마우스 오버 이벤트
                                layer.on('mouseover', function(e) {
                                    console.log('Mouseover on district:', districtName);
                                    highlightDistrict(districtName);
                                    layer.setStyle({
                                        fillOpacity: 0,
                                        fillColor: '#F9035E', // 핑크색
                                        weight: 3,
                                        color: '#F9035E' // 핑크색
                                    });
                                });
                                
                                layer.on('mouseout', function(e) {
                                    console.log('Mouseout from district:', districtName);
                                    clearDistrictHighlight();
                                    layer.setStyle(defaultStyle);
                                });
                                
                                layer.on('click', function(e) {
                                    // 이벤트 전파 중지
                                    if (e.originalEvent) {
                                        e.originalEvent.stopPropagation();
                                        e.originalEvent.preventDefault();
                                    }
                                    L.DomEvent.stopPropagation(e);
                                    L.DomEvent.stop(e);
                                    
                                    // 클릭한 위치의 좌표로 정확한 구역 찾기
                                    var clickLat = e.latlng.lat;
                                    var clickLng = e.latlng.lng;
                                    var clickedDistrict = findDistrictAtPoint(clickLat, clickLng);
                                    
                                    // 찾은 구역이 있으면 그것을 사용, 없으면 레이어의 구역 사용
                                    var targetDistrict = clickedDistrict || districtName;
                                    
                                    console.log('Click on district layer:', districtName, 'clicked district:', clickedDistrict, 'using:', targetDistrict);
                                    toggleDistrictFilter(targetDistrict);
                                });
                                
                                // 초기 스타일 설정
                                layer.setStyle(defaultStyle);
                            }
                        }
                    }).addTo(map);

                    var boundaryBounds = seoulBoundaryLayer.getBounds();
                    if (boundaryBounds.isValid()) {
                        var paddedBounds = boundaryBounds.pad(0.01);
                        map.fitBounds(paddedBounds);
                        // map.setMaxBounds(paddedBounds); // 위치 제한 제거
                        updateBaseTileLayer(paddedBounds);
                        applySeoulMask(seoulBoundaryPolygon, paddedBounds);
                    }

                })
                .catch(function(error) {
                    console.error('서울 경계선을 로드하는 중 오류 발생:', error);
                    throw error;
                });
        }

        function filterGeojsonByDistricts(geojson, normalizedWhitelist) {
            if (!geojson || !geojson.features || !geojson.features.length) {
                return geojson;
            }

            var filtered = geojson.features.filter(function(feature) {
                var props = feature.properties || {};
                var candidates = [
                    props.sggnm, props.SGGNM,
                    props.name, props.NAME,
                    props.adm_nm, props.ADM_NM
                ];
                return candidates.some(function(value) {
                    if (!value || typeof value !== 'string') {
                        return false;
                    }
                    var normalized = normalizeDistrictName(value);
                    return normalizedWhitelist.some(function(allowed) {
                        return normalized.indexOf(allowed) !== -1;
                    });
                });
            });

            if (!filtered.length) {
                return geojson;
            }

            return {
                type: 'FeatureCollection',
                features: filtered
            };
        }

        function aggregateDistrictBoundaries(geojson, normalizedWhitelist) {
            if (!geojson || !geojson.features || !geojson.features.length) {
                return geojson;
            }

            if (typeof turf === 'undefined' || !turf.union) {
                console.warn('Turf.js가 없어 구 경계 병합을 건너뜁니다.');
                return geojson;
            }

            var groups = {};
            geojson.features.forEach(function(feature) {
                var districtName = extractDistrictName(feature, normalizedWhitelist);
                if (!districtName) {
                    return;
                }
                if (!groups[districtName]) {
                    groups[districtName] = feature;
                } else {
                    try {
                        groups[districtName] = turf.union(groups[districtName], feature);
                    } catch (error) {
                        console.warn('구 경계 병합 중 오류 발생:', error);
                    }
                }
            });

            var aggregated = Object.keys(groups).map(function(name) {
                var mergedFeature = groups[name];
                if (!mergedFeature || !mergedFeature.geometry) {
                    return null;
                }
                mergedFeature.properties = mergedFeature.properties || {};
                mergedFeature.properties.districtName = name;
                return mergedFeature;
            }).filter(Boolean);

            if (!aggregated.length) {
                return geojson;
            }

            return {
                type: 'FeatureCollection',
                features: aggregated
            };
        }

        function mergeFeaturesForMask(geojson) {
            if (!geojson || !geojson.features || !geojson.features.length) {
                return null;
            }

            if (typeof turf === 'undefined' || !turf.union) {
                console.warn('Turf.js가 로드되지 않아 경계 병합을 건너뜁니다.');
                return geojson;
            }

            try {
                var merged = geojson.features[0];
                for (var i = 1; i < geojson.features.length; i++) {
                    merged = turf.union(merged, geojson.features[i]);
                }
                return {
                    type: 'FeatureCollection',
                    features: [merged]
                };
            } catch (error) {
                console.warn('서울 경계를 병합하는 중 오류가 발생했습니다. 원본 데이터를 사용합니다.', error);
                return geojson;
            }
        }

        function extractDistrictName(feature, normalizedWhitelist) {
            if (!feature || !feature.properties) {
                return null;
            }
            
            // aggregateDistrictBoundaries에서 추가한 districtName 속성 확인
            if (feature.properties.districtName) {
                return feature.properties.districtName;
            }
            
            var candidates = [
                feature.properties.sggnm, feature.properties.SGGNM,
                feature.properties.name, feature.properties.NAME,
                feature.properties.adm_nm, feature.properties.ADM_NM
            ];

            for (var i = 0; i < candidates.length; i++) {
                var value = candidates[i];
                if (!value || typeof value !== 'string') {
                    continue;
                }
                var normalized = normalizeDistrictName(value);
                for (var j = 0; j < normalizedWhitelist.length; j++) {
                    var allowed = normalizedWhitelist[j];
                    if (normalized.indexOf(allowed) !== -1) {
                        return seoulDistricts[j];
                    }
                }
            }
            return null;
        }

        function normalizeDistrictName(name) {
            if (!name) {
                return '';
            }
            return String(name).replace(/\s+/g, '').replace(/[^가-힣A-Za-z0-9]/g, '');
        }

        function applySeoulMask(polygonFeature, bounds) {
            if (!polygonFeature || !polygonFeature.geometry) {
                return;
            }

            if (seoulMaskLayer) {
                map.removeLayer(seoulMaskLayer);
                seoulMaskLayer = null;
            }

            var padding = 5;
            var outer = [
                [bounds.getNorthEast().lat + padding, bounds.getSouthWest().lng - padding],
                [bounds.getNorthEast().lat + padding, bounds.getNorthEast().lng + padding],
                [bounds.getSouthWest().lat - padding, bounds.getNorthEast().lng + padding],
                [bounds.getSouthWest().lat - padding, bounds.getSouthWest().lng - padding]
            ];

            var rings = extractPolygonRings(polygonFeature);
            if (!rings.length) {
                return;
            }

            seoulMaskLayer = L.polygon([outer].concat(rings), {
                color: '#000000',
                weight: 0,
                fillColor: '#000000',
                fillOpacity: 1,
                interactive: false,
                pane: 'maskPane'
            }).addTo(map);
        }

        function extractPolygonRings(feature) {
            var rings = [];
            if (!feature || !feature.geometry || !feature.geometry.coordinates) {
                return rings;
            }

            var coords = feature.geometry.coordinates;
            if (feature.geometry.type === 'Polygon') {
                coords.forEach(function(ring) {
                    rings.push(ring.map(function(coord) {
                        return [coord[1], coord[0]];
                    }));
                });
            } else if (feature.geometry.type === 'MultiPolygon') {
                coords.forEach(function(poly) {
                    poly.forEach(function(ring) {
                        rings.push(ring.map(function(coord) {
                            return [coord[1], coord[0]];
                        }));
                    });
                });
            }
            return rings;
        }

        function updateBaseTileLayer(bounds) {
            if (baseTileLayer) {
                map.removeLayer(baseTileLayer);
                baseTileLayer = null;
            }
            baseTileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                attribution: '© OpenStreetMap contributors © CARTO',
                subdomains: 'abcd',
                minZoom: 10,
                maxZoom: 40,
                bounds: bounds,
                noWrap: true,
                keepBuffer: 1,
                updateWhenIdle: true,
                updateWhenZooming: false
            });
            baseTileLayer.addTo(map);
        }

        function isLocationInSeoul(location) {
            if (!location) {
                return false;
            }
            var lat = parseFloat(location.lat);
            var lng = parseFloat(location.lng);
            if (!(lat && lng) || isNaN(lat) || isNaN(lng) ||
                lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                return false;
            }

            if (seoulBoundaryPolygon && typeof turf !== 'undefined' && turf.booleanPointInPolygon) {
                var point = turf.point([lng, lat]);
                try {
                    if (turf.booleanPointInPolygon(point, seoulBoundaryPolygon)) {
                        return true;
                    }
                } catch (error) {
                    console.warn('경계 다각형 검사 중 오류:', error);
                }
            }

            if (location.CTPRVN_NM && location.CTPRVN_NM.indexOf('서울') !== -1) {
                return true;
            }
            if (location.FCLTY_ROAD_NM_ADDR && location.FCLTY_ROAD_NM_ADDR.indexOf('서울특별시') !== -1) {
                return true;
            }
            if (location.SIGNGU_NM && seoulDistricts.indexOf(location.SIGNGU_NM) !== -1) {
                return true;
            }
            return seoulBounds.contains([lat, lng]);
        }
        
        function loadMarkers() {
        
        // Google Maps API 키가 있는 경우 아래 주석을 해제하여 Google Maps 스타일을 사용할 수 있습니다
        /*
        if (typeof GOOGLE_MAPS_API_KEY !== 'undefined' && GOOGLE_MAPS_API_KEY !== 'YOUR_API_KEY') {
            // Google Maps API 스크립트 동적 로드
            var script = document.createElement('script');
            script.src = 'https://maps.googleapis.com/maps/api/js?key=' + GOOGLE_MAPS_API_KEY + '&libraries=geometry&callback=initGoogleMap';
            document.head.appendChild(script);
            
            // Leaflet Google Mutant Plugin 로드
            var mutantScript = document.createElement('script');
            mutantScript.src = 'https://unpkg.com/leaflet.gridlayer.googlemutant@latest/dist/Leaflet.GoogleMutant.js';
            mutantScript.onload = function() {
                window.initGoogleMap = function() {
                    var googleLayer = L.gridLayer.googleMutant({
                        type: 'roadmap',
                        styles: mapStyle
                    });
                    map.removeLayer(map._layers[Object.keys(map._layers)[0]]); // 기존 타일 제거
                    googleLayer.addTo(map);
                };
            };
            document.head.appendChild(mutantScript);
        }

        */

            // data.json 파일 로드 (CORS 문제 해결: fetch와 XMLHttpRequest 모두 시도)
            function processData(data) {
                console.log('데이터 로드 성공:', data.length, '개 항목');
                
                var filteredData = data.filter(isLocationInSeoul);
                console.log('서울 데이터 필터링:', filteredData.length, '개 항목');
                
                // 모든 마커를 저장할 배열
                var markers = [];
                var invalidCount = 0;
                
                // 각 위치에 마커 추가
                filteredData.forEach(function(location, index) {
                    // 위도와 경도 확인 (업데이트된 JSON 구조: lat, lng 사용)
                    var lat = parseFloat(location.lat);
                    var lng = parseFloat(location.lng);
                    
                    // 유효한 좌표인지 확인 (0이 아니고, 숫자이고, 유효한 범위 내)
                    if (lat && lng && !isNaN(lat) && !isNaN(lng) && 
                        lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
                        // Tooltip 내용 구성 (마우스 오버 시 표시)
                        var facilityName = location.FCLTY_NM || '자전거 대여소';
                        // 대여소 이름에서 넘버링 제거
                        facilityName = String(facilityName).replace(/^\d+\.\s*/, '').trim();
                        var tooltipContent = '<div style="font-weight: bold; margin-bottom: 3px;">' + facilityName + '</div>';
                        if (location.SIGNGU_NM) {
                            tooltipContent += '<div style="font-size: 12px; color: #ddd;">' + location.SIGNGU_NM + '</div>';
                        }
                        
                        // 마커 생성 (아직 지도에 추가하지 않음)
                        var district = location.SIGNGU_NM || '기타';
                        var marker = L.marker([lat, lng], { 
                            icon: bikeMarkerIcon,
                            district: district,
                            locationData: location // 위치 데이터 저장
                        })
                            .bindTooltip(tooltipContent, {
                                permanent: false,
                                direction: 'top',
                                className: 'custom-tooltip',
                                offset: [0, -10]
                            });
                        
                        // Popup 내용을 함수로 생성 (팝업이 열릴 때마다 최신 내용 생성)
                        marker.bindPopup(function() {
                            var popupContent = '<div class="info">';
                            var facilityName = location.FCLTY_NM || '자전거 대여소';
                            // 대여소 이름에서 넘버링 제거
                            facilityName = String(facilityName).replace(/^\d+\.\s*/, '').trim();
                            popupContent += '<strong style="font-size: 16px; display: block; margin-bottom: 8px;">' + facilityName + '</strong>';
                            
                            if (location.LCLAS_NM) {
                                popupContent += '<div style="margin-bottom: 5px;"><span style="color: #666;">시설분류:</span> ' + 
                                    location.LCLAS_NM + '</div>';
                            }
                            
                            if (location.FCLTY_ROAD_NM_ADDR) {
                                popupContent += '<div style="margin-bottom: 5px;"><span style="color: #666;">주소:</span><br>' + 
                                    location.FCLTY_ROAD_NM_ADDR + '</div>';
                            }
                            
                            if (location.SIGNGU_NM) {
                                popupContent += '<div style="margin-bottom: 5px;"><span style="color: #666;">시군구:</span> ' + 
                                    location.SIGNGU_NM + '</div>';
                            }
                            
                            if (location.LEGALDONG_NM) {
                                popupContent += '<div style="margin-bottom: 5px;"><span style="color: #666;">법정동:</span> ' + 
                                    location.LEGALDONG_NM + '</div>';
                            }
                            
                            if (location.BULD_NM) {
                                popupContent += '<div style="margin-bottom: 5px;"><span style="color: #666;">건물명:</span> ' + 
                                    location.BULD_NM + '</div>';
                            }
                            
                            if (location.CTPRVN_NM) {
                                popupContent += '<div style="margin-bottom: 5px;"><span style="color: #666;">시도:</span> ' + 
                                    location.CTPRVN_NM + '</div>';
                            }
                            
                            if (location.MLSFC_NM) {
                                popupContent += '<div style="margin-bottom: 5px;"><span style="color: #666;">상세분류:</span> ' + 
                                    location.MLSFC_NM + '</div>';
                            }
                            
                            if (location.ADDR_ENG_NM) {
                                popupContent += '<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #eee; font-size: 12px; color: #888;">' + 
                                    location.ADDR_ENG_NM + '</div>';
                            }
                            
                            popupContent += '</div>';
                            return popupContent;
                        }, {
                            maxWidth: 300
                        });
                        
                        // 마커 클릭 이벤트: 자동으로 출발지/도착지 설정
                        marker.on('click', function(e) {
                            // 클릭 애니메이션 효과 추가
                            var iconElement = marker._icon;
                            if (iconElement) {
                                var markerDiv = iconElement.querySelector('.bike-marker');
                                if (markerDiv) {
                                    markerDiv.classList.add('marker-clicked');
                                    setTimeout(function() {
                                        markerDiv.classList.remove('marker-clicked');
                                    }, 400);
                                }
                            }
                            
                            // 팝업 버튼 클릭과 구분하기 위해 약간의 지연
                            setTimeout(function() {
                                var markerLat = marker.getLatLng().lat;
                                var markerLng = marker.getLatLng().lng;
                                var markerName = location.FCLTY_NM || '자전거 대여소';
                                // 대여소 이름에서 넘버링 제거
                                markerName = String(markerName).replace(/^\d+\.\s*/, '').trim();
                                var markerDistrict = district; // 구역 정보
                                
                                // 같은 위치인지 확인하는 함수
                                function isSameLocation(loc1, loc2) {
                                    if (!loc1 || !loc2) return false;
                                    // 약 10미터 이내면 같은 위치로 간주
                                    var latDiff = Math.abs(loc1.lat - loc2.lat);
                                    var lngDiff = Math.abs(loc1.lng - loc2.lng);
                                    return latDiff < 0.0001 && lngDiff < 0.0001;
                                }
                                
                                // 출발지와 도착지가 모두 설정되어 있고, 클릭한 위치가 출발지와 같으면 경로 초기화
                                if (startLocation && endLocation && isSameLocation(startLocation, {lat: markerLat, lng: markerLng})) {
                                    clearRoute();
                                    return;
                                }
                                
                                // 출발지와 도착지가 모두 설정되어 있으면 기존 경로 초기화
                                if (startLocation && endLocation) {
                                    clearRoute();
                                }
                                
                                // 출발지가 없으면 출발지로 설정
                                if (!startLocation) {
                                    setStartLocation(markerLat, markerLng, markerName, markerDistrict);
                                }
                                // 출발지가 있고 도착지가 없으면 도착지로 설정 (단, 같은 위치가 아닐 때만)
                                else if (!endLocation) {
                                    // 출발지와 같은 위치가 아니면 도착지로 설정
                                    if (!isSameLocation(startLocation, {lat: markerLat, lng: markerLng})) {
                                        setEndLocation(markerLat, markerLng, markerName, markerDistrict);
                                    }
                                }
                                // 출발지와 도착지가 모두 설정되어 있고, 클릭한 위치가 도착지와 같으면 경로 초기화
                                else if (startLocation && endLocation && isSameLocation(endLocation, {lat: markerLat, lng: markerLng})) {
                                    clearRoute();
                                }
                            }, 50);
                        });
                        
                        
                        markers.push(marker);
                        
                        // 구별 마커 저장
                        if (!markersByDistrict[district]) {
                            markersByDistrict[district] = [];
                        }
                        markersByDistrict[district].push(marker);
                    } else {
                        invalidCount++;
                        if (index < 5) { // 처음 5개만 로그
                            console.warn('유효하지 않은 좌표:', index, location);
                        }
                    }
                });

                console.log('유효한 마커:', markers.length, '개');
                console.log('유효하지 않은 데이터:', invalidCount, '개');

                // 기존 클러스터 그룹 제거
                for (var district in clusterGroupsByDistrict) {
                    if (clusterGroupsByDistrict.hasOwnProperty(district)) {
                        map.removeLayer(clusterGroupsByDistrict[district]);
                    }
                }
                clusterGroupsByDistrict = {};
                
                if (markerClusterGroup) {
                    map.removeLayer(markerClusterGroup);
                    markerClusterGroup = null;
                }

                if (markers.length > 0) {
                        // 전체 마커 배열 저장
                        allMarkers = markers.slice();
                        
                        // 구별로 클러스터 그룹 생성
                        for (var district in markersByDistrict) {
                            if (markersByDistrict.hasOwnProperty(district) && markersByDistrict[district].length > 0) {
                                var clusterGroup = L.markerClusterGroup({
                                    showCoverageOnHover: false,
                                    maxClusterRadius: 95,
                                    spiderfyOnMaxZoom: false,
                                    disableClusteringAtZoom: clusterOnlyMaxZoom + 1,
                                    removeOutsideVisibleBounds: false, // 화면 밖 마커도 유지
                                    iconCreateFunction: function(cluster) {
                                        var count = cluster.getChildCount();
                                        var sizeClass = 'cluster-small';
                                        if (count >= 50) {
                                            sizeClass = 'cluster-large';
                                        } else if (count >= 20) {
                                            sizeClass = 'cluster-medium';
                                        }
                                        return L.divIcon({
                                            html: '<div class="bike-cluster ' + sizeClass + '"><span>' + count + '</span></div>',
                                            className: '',
                                            iconSize: [48, 48],
                                            iconAnchor: [24, 24]
                                        });
                                    }
                                });
                                
                                // 클러스터 그룹 생성 (마커는 나중에 updateMarkers에서 추가)
                                clusterGroupsByDistrict[district] = clusterGroup;
                                
                                // 클러스터 그룹은 지도에 추가하지 않음 (updateMarkers에서 필요할 때만 추가)
                            }
                        }
                        
                        // 레거시 호환을 위한 단일 클러스터 그룹 (사용하지 않지만 참조용)
                        markerClusterGroup = {
                            clearLayers: function() {
                                for (var d in clusterGroupsByDistrict) {
                                    if (clusterGroupsByDistrict.hasOwnProperty(d)) {
                                        clusterGroupsByDistrict[d].clearLayers();
                                    }
                                }
                            },
                            addLayers: function(markerArray) {
                                // 구별로 분류하여 해당 클러스터 그룹에 추가
                                var markersByDist = {};
                                markerArray.forEach(function(marker) {
                                    var dist = marker.options.district;
                                    if (!markersByDist[dist]) {
                                        markersByDist[dist] = [];
                                    }
                                    markersByDist[dist].push(marker);
                                });
                                
                                for (var dist in markersByDist) {
                                    if (clusterGroupsByDistrict[dist]) {
                                        clusterGroupsByDistrict[dist].addLayers(markersByDist[dist]);
                                    }
                                }
                            }
                        };

                    // 모든 마커를 포함하는 범위 계산
                    var group = new L.featureGroup(markers);
                    map.fitBounds(group.getBounds().pad(0.1));
                    var currentZoom = map.getZoom();
                    if (currentZoom > clusterOnlyMaxZoom) {
                        map.setZoom(clusterOnlyMaxZoom);
                    }
                    console.log('지도 범위 조정 완료');
                    
                    // 초기 상태: 마커 표시 안 함 (옵션 패널 설정에 따라)
                    updateMarkers();
                    
                    // 지도 클릭 이벤트 초기화
                    initMapClickHandler();
                } else {
                    console.error('표시할 마커가 없습니다. 데이터를 확인해주세요.');
                    alert('표시할 마커가 없습니다. 브라우저 콘솔을 확인해주세요.');
                }
            }
            
            function handleError(error, method) {
                console.error('데이터를 불러오는 중 오류가 발생했습니다 (' + method + '):', error);
                var errorMsg = '데이터를 불러올 수 없습니다.\n\n';
                errorMsg += '가능한 원인:\n';
                errorMsg += '1. CORS 정책 (file:// 프로토콜 사용 시)\n';
                errorMsg += '2. data.json 파일이 같은 폴더에 없음\n';
                errorMsg += '3. 파일 경로 오류\n\n';
                errorMsg += '해결 방법:\n';
                errorMsg += '로컬 웹 서버를 사용하세요:\n';
                errorMsg += '- Python: python -m http.server 8000\n';
                errorMsg += '- Node.js: npx http-server\n';
                errorMsg += '그 후 http://localhost:8000/index.html 접속\n\n';
                errorMsg += '에러: ' + (error.message || error);
                alert(errorMsg);
            }
            
            // 먼저 fetch 시도 (HTTP 서버 사용 시)
            fetch('data.json')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('HTTP error! status: ' + response.status);
                    }
                    return response.json();
                })
                .then(data => {
                    processData(data);
                })
                .catch(fetchError => {
                    // fetch 실패 시 XMLHttpRequest 시도 (file:// 프로토콜 대응)
                    console.warn('fetch 실패, XMLHttpRequest로 재시도:', fetchError);
                    var xhr = new XMLHttpRequest();
                    xhr.open('GET', 'data.json', true);
                    xhr.onreadystatechange = function() {
                        if (xhr.readyState === 4) {
                            if (xhr.status === 200 || xhr.status === 0) { // 0은 file:// 프로토콜에서 성공
                                try {
                                    var data = JSON.parse(xhr.responseText);
                                    processData(data);
                                } catch (parseError) {
                                    handleError(parseError, 'XMLHttpRequest (JSON 파싱)');
                                }
                            } else {
                                handleError(new Error('HTTP status: ' + xhr.status), 'XMLHttpRequest');
                            }
                        }
                    };
                    xhr.onerror = function() {
                        handleError(new Error('Network error'), 'XMLHttpRequest');
                    };
                    xhr.send(null);
                });
        }
        
        // 옵션 패널 초기화
        function initOptionsPanel() {
            var districtFilters = document.getElementById('district-filters');
            
            // 이미 초기화되었으면 체크박스만 업데이트
            if (districtFilters.children.length === 0) {
                seoulDistricts.forEach(function(district, index) {
                    var label = document.createElement('label');
                    label.className = 'district-checkbox';
                    
                    // 체크박스 생성
                    var checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'district-filter';
                    checkbox.setAttribute('data-district', district);
                    
                    // 지역 이름에서 모든 넘버링 제거 (더 강력한 방법)
                    var displayName = String(district);
                    // 모든 가능한 넘버링 패턴 제거
                    displayName = displayName.replace(/^[^가-힣]*/, ''); // 한글이 나오기 전의 모든 문자 제거
                    displayName = displayName.trim();
                    
                    // 체크박스와 텍스트를 label에 추가
                    label.appendChild(checkbox);
                    label.appendChild(document.createTextNode(' ' + displayName));
                    
                    districtFilters.appendChild(label);
                });
                
                // 구별 필터 체크박스 이벤트 리스너
                document.querySelectorAll('.district-filter').forEach(function(checkbox) {
                    checkbox.addEventListener('change', function(e) {
                        // 다중 선택 모드: 여러 지역을 동시에 선택 가능
                        updateMarkers();
                        // 자전거 대여소 마커도 업데이트 (지역 선택 시마다 API 호출)
                        updateBikeStationMarkers();
                    });
                });
            }
            
            // 구별 필터 접기/펼치기 기능
            var districtFilterHeader = document.getElementById('district-filter-header');
            var districtFilters = document.getElementById('district-filters');
            if (districtFilterHeader && districtFilters) {
                districtFilterHeader.addEventListener('click', function(e) {
                    e.stopPropagation();
                    var isCollapsed = districtFilters.style.display === 'none';
                    var toggleIcon = districtFilterHeader.querySelector('.district-toggle-icon');
                    
                    if (isCollapsed) {
                        districtFilters.style.display = 'block';
                        if (toggleIcon) toggleIcon.textContent = '▼';
                    } else {
                        districtFilters.style.display = 'none';
                        if (toggleIcon) toggleIcon.textContent = '▶';
                    }
                });
            }
            
            // 패널 드래그 기능 제거 (화면 가장자리에 고정)
            
            // 자전거 대여소 정보 기능 초기화
            initBikeStations();
            
            // 경로 찾기 기능 초기화
            initRouteControls();
            
            // 사용량 보기 체크박스 이벤트 리스너
            var showUsageCheckbox = document.getElementById('show-usage-view');
            if (showUsageCheckbox) {
                showUsageCheckbox.addEventListener('change', function() {
                    updateMarkerColors();
                });
            }
        }
        
        // 자전거 대여소 정보 기능 초기화
        function initBikeStations() {
            // 페이지 로드 시 즉시 데이터를 미리 로드 (지역 선택 시 빠른 반응을 위해)
            loadBikeStations();
            
            var clearBtn = document.getElementById('clear-bike-stations');
            if (clearBtn) {
                clearBtn.addEventListener('click', function() {
                    clearBikeStationMarkers();
                    clearBtn.style.display = 'none';
                });
            }
        }
        
        // 자전거 대여소 정보 로드 (최적화: 첫 호출 제거하고 바로 3개 병렬 호출)
        function loadBikeStations() {
            // 데이터가 이미 로드 중이거나 로드 완료되었으면 중복 호출 방지
            if (isDataLoaded) {
                return;
            }
            
            // 바로 3회로 나누어 병렬 호출 (첫 호출 제거로 시간 단축)
            var calls = [
                { start: 1, end: 1000 },
                { start: 1001, end: 2000 },
                { start: 2001, end: 2540 }
            ];
            
            var responseKey = null; // 첫 번째 응답에서 결정
            
            // 모든 호출을 병렬로 실행
            var fetchPromises = calls.map(function(call, index) {
                var pageApiUrl = getApiUrl('/json/bikeList/' + call.start + '/' + call.end + '/');
                
                return fetchWithRetry(pageApiUrl, 1, 300, '/json/bikeList/' + call.start + '/' + call.end + '/')
                    .then(function(pageData) {
                        // 응답 구조 확인 (첫 번째 호출에서만)
                        if (!responseKey) {
                            if (pageData.bikeList && pageData.bikeList.list_total_count) {
                                responseKey = 'bikeList';
                            } else {
                                for (var key in pageData) {
                                    if (pageData[key] && pageData[key].list_total_count) {
                                        responseKey = key;
                                        break;
                                    }
                                }
                            }
                        }
                        
                        // 응답 구조에 따라 데이터 추출
                        var rows = [];
                        if (pageData[responseKey] && pageData[responseKey].row) {
                            rows = Array.isArray(pageData[responseKey].row) ? 
                                   pageData[responseKey].row : 
                                   [pageData[responseKey].row];
                        }
                        return rows;
                    })
                    .catch(function(error) {
                        var errorMsg = error.message || error.toString();
                        if (errorMsg.includes('Failed to fetch') || errorMsg.includes('NetworkError')) {
                            console.error((index + 1) + '회 호출 실패: 네트워크 오류');
                        } else {
                            console.error((index + 1) + '회 호출 실패:', errorMsg);
                        }
                        return [];
                    });
            });
            
            // 모든 페이지 데이터를 기다린 후 합치기
            Promise.all(fetchPromises)
                .then(function(allPagesData) {
                    // 모든 페이지의 데이터를 하나로 합치기
                    var allRows = [];
                    if (allPagesData && allPagesData.length > 0) {
                        allPagesData.forEach(function(pageRows) {
                            if (pageRows && pageRows.length > 0) {
                                allRows = allRows.concat(pageRows);
                            }
                        });
                    }
                    
                    // 모든 데이터 저장 (지역 선택 시에만 표시)
                    allBikeStationData = allRows;
                    isDataLoaded = true; // 데이터 로드 완료 표시
                    
                    // 데이터 로드 완료 후 지역 필터가 선택되어 있으면 마커 표시
                    var hasSelectedDistrict = false;
                    document.querySelectorAll('.district-filter').forEach(function(checkbox) {
                        if (checkbox.checked) {
                            hasSelectedDistrict = true;
                        }
                    });
                    
                    // 데이터 로드 완료 후 선택된 지역이 있으면 자동으로 마커 표시
                    if (hasSelectedDistrict) {
                        updateBikeStationMarkers();
                    }
                    
                    // 버튼 상태 업데이트
                    var clearBtn = document.getElementById('clear-bike-stations');
                    if (clearBtn) {
                        clearBtn.style.display = 'block';
                    }
                })
                .catch(function(error) {
                    var errorMsg = error.message || error.toString();
                    if (errorMsg.includes('Failed to fetch') || errorMsg.includes('NetworkError')) {
                        console.error('자전거 대여소 정보 API 호출 실패: 네트워크 오류 또는 CORS 문제');
                        alert('API 서버에 연결할 수 없습니다.\n\n가능한 원인:\n1. 인터넷 연결을 확인하세요\n2. API 서버 상태를 확인하세요\n3. 브라우저 콘솔에서 자세한 오류를 확인하세요');
                    } else {
                        console.error('자전거 대여소 정보 API 호출 실패:', errorMsg);
                        alert('데이터를 불러오는 중 오류가 발생했습니다: ' + errorMsg);
                    }
                });
        }
        
        // 자전거 대여소 마커 업데이트 (지역 필터 적용)
        function updateBikeStationMarkers() {
            // 선택된 지역 필터 가져오기
            var visibleDistricts = [];
            document.querySelectorAll('.district-filter').forEach(function(checkbox) {
                if (checkbox.checked) {
                    visibleDistricts.push(checkbox.dataset.district);
                }
            });
            
            // 출발지/도착지가 표시되는 구역에 있는지 확인
            var shouldClearRoute = false;
            if (startLocation && startLocation.district) {
                if (visibleDistricts.indexOf(startLocation.district) === -1) {
                    shouldClearRoute = true;
                }
            }
            if (endLocation && endLocation.district) {
                if (visibleDistricts.indexOf(endLocation.district) === -1) {
                    shouldClearRoute = true;
                }
            }
            
            // 출발지/도착지가 표시되지 않는 구역에 있으면 경로 초기화
            if (shouldClearRoute) {
                clearRoute();
            }
            
            // 지역이 선택되지 않았으면 모든 마커 제거
            if (visibleDistricts.length === 0) {
                clearBikeStationMarkers();
                return;
            }
            
            // 데이터가 이미 로드되어 있으면 즉시 필터링 (API 호출 없음)
            if (isDataLoaded && allBikeStationData.length > 0) {
                var cacheKey = visibleDistricts.slice().sort().join(',');
                if (bikeStationCache[cacheKey]) {
                    clearBikeStationMarkers();
                    displayFilteredBikeStationMarkers(bikeStationCache[cacheKey]);
                    return;
                }
                // 캐시에 없으면 필터링만 수행
                var filtered = filterBikeStationsByDistricts(allBikeStationData, visibleDistricts);
                bikeStationCache[cacheKey] = filtered;
                clearBikeStationMarkers();
                displayFilteredBikeStationMarkers(filtered);
                return;
            }
            
            // 데이터가 아직 로드되지 않았으면 로드 중... (백그라운드에서 로드)
            // loadBikeStations가 완료되면 자동으로 updateBikeStationMarkers가 호출됨
            if (!isDataLoaded) {
                // 데이터 로드 중이면 로드 완료를 기다림
                var checkInterval = setInterval(function() {
                    if (isDataLoaded) {
                        clearInterval(checkInterval);
                        // 데이터 로드 완료 후 필터링
                        var cacheKey = visibleDistricts.slice().sort().join(',');
                        if (bikeStationCache[cacheKey]) {
                            clearBikeStationMarkers();
                            displayFilteredBikeStationMarkers(bikeStationCache[cacheKey]);
                        } else {
                            var filtered = filterBikeStationsByDistricts(allBikeStationData, visibleDistricts);
                            bikeStationCache[cacheKey] = filtered;
                            clearBikeStationMarkers();
                            displayFilteredBikeStationMarkers(filtered);
                        }
                    }
                }, 100); // 100ms마다 확인
                return;
            }
            
            // 데이터가 이미 로드되어 있으면 즉시 필터링 (위에서 이미 처리됨)
        }
        
        // 지역별로 API 호출 및 필터링 (데이터가 없을 때만 호출)
        function loadAndFilterBikeStations(visibleDistricts) {
            // 데이터가 이미 로드되어 있으면 필터링만 수행 (이미 updateBikeStationMarkers에서 처리됨)
            if (isDataLoaded && allBikeStationData.length > 0) {
                var cacheKey = visibleDistricts.slice().sort().join(',');
                if (bikeStationCache[cacheKey]) {
                    clearBikeStationMarkers();
                    displayFilteredBikeStationMarkers(bikeStationCache[cacheKey]);
                    return;
                }
                var filtered = filterBikeStationsByDistricts(allBikeStationData, visibleDistricts);
                bikeStationCache[cacheKey] = filtered;
                clearBikeStationMarkers();
                displayFilteredBikeStationMarkers(filtered);
                return;
            }
            
            // 데이터가 없을 때만 API 호출 (3회로 나누어 호출)
            var calls = [
                { start: 1, end: 1000 },
                { start: 1001, end: 2000 },
                { start: 2001, end: 2540 }
            ];
            
            var allFilteredRows = [];
            var responseKey = null;
            
            // 각 호출을 순차적으로 실행하고 필터링
            var fetchPromises = calls.map(function(call, index) {
                var pageApiUrl = getApiUrl('/json/bikeList/' + call.start + '/' + call.end + '/');
                
                // 로그 최소화로 성능 향상
                return fetchWithRetry(pageApiUrl, 1, 300, '/json/bikeList/' + call.start + '/' + call.end + '/')
                    .then(function(pageData) {
                        // 응답 구조 확인 (첫 번째 호출에서만)
                        if (!responseKey) {
                            if (pageData.bikeList && pageData.bikeList.list_total_count) {
                                responseKey = 'bikeList';
                            } else {
                                for (var key in pageData) {
                                    if (pageData[key] && pageData[key].list_total_count) {
                                        responseKey = key;
                                        break;
                                    }
                                }
                            }
                        }
                        
                        // 응답 구조에 따라 데이터 추출
                        var rows = [];
                        if (pageData[responseKey] && pageData[responseKey].row) {
                            rows = Array.isArray(pageData[responseKey].row) ? 
                                   pageData[responseKey].row : 
                                   [pageData[responseKey].row];
                        }
                        
                        // 즉시 필터링 수행 (로그 제거로 성능 향상)
                        var filtered = filterBikeStationsByDistricts(rows, visibleDistricts);
                        
                        return filtered;
                    })
                    .catch(function(error) {
                        var errorMsg = error.message || error.toString();
                        if (errorMsg.includes('Failed to fetch') || errorMsg.includes('NetworkError')) {
                            console.error((index + 1) + '회 호출 실패: 네트워크 오류 또는 CORS 문제. API 서버에 연결할 수 없습니다.');
                            console.error('가능한 원인: 1) 인터넷 연결 확인 2) API 서버 상태 확인 3) CORS 정책 확인');
                        } else {
                            console.error((index + 1) + '회 호출 실패:', errorMsg);
                        }
                        return [];
                    });
            });
            
            // 모든 호출 완료 후 결과 합치기
            Promise.all(fetchPromises)
                .then(function(allFilteredResults) {
                    // 모든 필터링된 결과 합치기
                    allFilteredResults.forEach(function(filteredRows) {
                        if (filteredRows && filteredRows.length > 0) {
                            allFilteredRows = allFilteredRows.concat(filteredRows);
                        }
                    });
                    
                    // 캐시에 저장 (로그 제거로 성능 향상)
                    bikeStationCache[cacheKey] = allFilteredRows;
                    
                    // 새 데이터가 준비된 후에만 기존 마커 제거하고 새 마커 표시
                    // 이렇게 하면 마커가 사라졌다 나타나는 현상을 방지
                    clearBikeStationMarkers();
                    
                    if (allFilteredRows.length > 0) {
                        displayFilteredBikeStationMarkers(allFilteredRows);
                    } else {
                        console.log('선택된 지역에 해당하는 대여소가 없습니다.');
                    }
                })
                .catch(function(error) {
                    console.error('대여소 로드 및 필터링 실패:', error);
                    // 에러 발생 시에도 기존 마커는 유지
                });
        }
        
        // 대여소 데이터를 지역별로 필터링 (위도/경도 기반, 최적화)
        function filterBikeStationsByDistricts(rows, visibleDistricts) {
            if (!rows || rows.length === 0 || !visibleDistricts || visibleDistricts.length === 0) {
                return [];
            }
            
            // Turf.js 사용 가능 여부 확인
            if (typeof turf === 'undefined' || !turf.booleanPointInPolygon) {
                return [];
            }
            
            var filteredRows = [];
            
            // 선택된 지역의 GeoJSON feature 가져오기
            var selectedDistrictFeatures = [];
            visibleDistricts.forEach(function(districtName) {
                if (districtFeatures[districtName]) {
                    selectedDistrictFeatures.push(districtFeatures[districtName]);
                }
            });
            
            if (selectedDistrictFeatures.length === 0) {
                return [];
            }
            
            var filteredRows = [];
            
            // 최적화: for 루프 사용 (forEach보다 빠름)
            for (var idx = 0; idx < rows.length; idx++) {
                var row = rows[idx];
                // 좌표 추출
                var lat = parseFloat(row.lat || row.LAT || row.stationLatitude || row.latitude);
                var lng = parseFloat(row.lng || row.LNG || row.stationLongitude || row.longitude);
                
                // 유효한 좌표인지 확인
                if (!lat || !lng || isNaN(lat) || isNaN(lng) || 
                    lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                    continue; // 유효하지 않은 좌표는 제외
                }
                
                // 대여소 위치를 Turf Point로 생성 (GeoJSON 형식: [경도, 위도])
                var stationPoint = turf.point([lng, lat]);
                
                // 선택된 지역 중 하나라도 포함되면 매칭 (최적화: break 즉시 사용)
                for (var i = 0; i < selectedDistrictFeatures.length; i++) {
                    try {
                        if (turf.booleanPointInPolygon(stationPoint, selectedDistrictFeatures[i])) {
                            filteredRows.push(row);
                            break; // 매칭되면 즉시 종료
                        }
                    } catch (error) {
                        // 에러는 무시하고 계속 진행
                    }
                }
            }
            
            // 로그 제거로 성능 향상
            return filteredRows;
        }
        
        // 필터링된 대여소 마커 표시 (최적화)
        function displayFilteredBikeStationMarkers(filteredRows) {
            if (!filteredRows || filteredRows.length === 0) {
                return;
            }
            
            // 기존 마커는 이미 clearBikeStationMarkers()에서 제거되었으므로 여기서는 제거하지 않음
            
            // 마커 그룹 생성 (클러스터링 사용)
            bikeStationMarkerGroup = L.markerClusterGroup({
                showCoverageOnHover: false,
                maxClusterRadius: 80,
                spiderfyOnMaxZoom: false,
                disableClusteringAtZoom: 17,
                removeOutsideVisibleBounds: false,
                iconCreateFunction: function(cluster) {
                    var count = cluster.getChildCount();
                    var sizeClass = 'cluster-small';
                    if (count >= 50) {
                        sizeClass = 'cluster-large';
                    } else if (count >= 20) {
                        sizeClass = 'cluster-medium';
                    }
                    return L.divIcon({
                        html: '<div class="bike-cluster ' + sizeClass + '"><span>' + count + '</span></div>',
                        className: '',
                        iconSize: [48, 48],
                        iconAnchor: [24, 24]
                    });
                }
            });
            
            // 각 대여소에 마커 추가
            filteredRows.forEach(function(row) {
                // 좌표 확인 (API 응답 구조에 따라 필드명이 다를 수 있음)
                var lat = parseFloat(row.lat || row.LAT || row.stationLatitude || row.latitude);
                var lng = parseFloat(row.lng || row.LNG || row.stationLongitude || row.longitude);
                
                // 유효한 좌표인지 확인
                if (lat && lng && !isNaN(lat) && !isNaN(lng) && 
                    lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
                    
                    // 대여소 이름
                    var stationName = row.stationName || row.STATION_NAME || row.name || '자전거 대여소';
                    // 대여소 이름에서 넘버링 제거 (예: "465.삼청공원 앞" -> "삼청공원 앞")
                    stationName = String(stationName).replace(/^\d+\.\s*/, '').trim();
                    
                    // 거치율 계산
                    var parkingBikeCnt = parseFloat(row.parkingBikeTotCnt || row.PARKING_BIKE_TOT_CNT || row.parkingBikeTotalCnt || 0);
                    var rackTotCnt = parseFloat(row.rackTotCnt || row.RACK_TOT_CNT || row.rackTotalCnt || 1);
                    var usageRate = rackTotCnt > 0 ? (parkingBikeCnt / rackTotCnt) * 100 : 0;
                    
                    // 마커 아이콘 생성 (기본 스타일 유지)
                    var apiMarkerIcon = L.divIcon({
                        className: '',
                        html: '<div class="bike-marker"><div class="bike-marker__inner"></div></div>',
                        iconSize: [34, 44],
                        iconAnchor: [17, 42],
                        popupAnchor: [0, -36],
                        tooltipAnchor: [0, -30]
                    });
                    
                    // 마커에 거치율 정보 저장 (나중에 색상 업데이트용)
                    var markerData = {
                        usageRate: usageRate,
                        parkingBikeCnt: parkingBikeCnt,
                        rackTotCnt: rackTotCnt
                    };
                    
                    // 지역 정보 추출 및 저장
                    var district = row.SIGNGU_NM || row.sigunguNm || row.district || row.gu || 
                                  row.stationGrpName || row.구 || row.시군구 || '기타';
                    
                    // 마커 생성 (지역 정보 포함)
                    var marker = L.marker([lat, lng], { 
                        icon: apiMarkerIcon,
                        district: district,
                        stationData: row,
                        markerData: markerData // 거치율 정보 저장
                    })
                    .bindTooltip(stationName, {
                                permanent: false,
                                direction: 'top',
                                className: 'custom-tooltip',
                                offset: [0, -10]
                    })
                    // 마커 클릭 시 패널에 정보 표시 및 길찾기 기능
                    .on('click', function(e) {
                        e.originalEvent.stopPropagation();
                        
                        // 클릭 애니메이션 효과 추가
                        var iconElement = marker._icon;
                        if (iconElement) {
                            var markerDiv = iconElement.querySelector('.bike-marker');
                            if (markerDiv) {
                                markerDiv.classList.add('marker-clicked');
                                setTimeout(function() {
                                    markerDiv.classList.remove('marker-clicked');
                                }, 400);
                            }
                        }
                        
                        // 패널에 정보 표시
                        showStationInfo(stationName, row);
                        
                        // 길찾기 기능: 출발지/도착지 설정
                        // 팝업 버튼 클릭과 구분하기 위해 약간의 지연
                        setTimeout(function() {
                            var markerLat = marker.getLatLng().lat;
                            var markerLng = marker.getLatLng().lng;
                            var markerName = stationName;
                            var markerDistrict = district;
                            
                            // 같은 위치인지 확인하는 함수
                            function isSameLocation(loc1, loc2) {
                                if (!loc1 || !loc2) return false;
                                // 약 10미터 이내면 같은 위치로 간주
                                var latDiff = Math.abs(loc1.lat - loc2.lat);
                                var lngDiff = Math.abs(loc1.lng - loc2.lng);
                                return latDiff < 0.0001 && lngDiff < 0.0001;
                            }
                            
                            // 출발지와 도착지가 모두 설정되어 있고, 클릭한 위치가 출발지와 같으면 경로 초기화
                            if (startLocation && endLocation && isSameLocation(startLocation, {lat: markerLat, lng: markerLng})) {
                                clearRoute();
                                return;
                            }
                            
                            // 출발지와 도착지가 모두 설정되어 있으면 기존 경로 초기화
                            if (startLocation && endLocation) {
                                clearRoute();
                            }
                            
                            // 출발지가 없으면 출발지로 설정
                            if (!startLocation) {
                                setStartLocation(markerLat, markerLng, markerName, markerDistrict);
                            }
                            // 출발지가 있고 도착지가 없으면 도착지로 설정 (단, 같은 위치가 아닐 때만)
                            else if (!endLocation) {
                                // 출발지와 같은 위치가 아니면 도착지로 설정
                                if (!isSameLocation(startLocation, {lat: markerLat, lng: markerLng})) {
                                    setEndLocation(markerLat, markerLng, markerName, markerDistrict);
                                }
                            }
                            // 출발지와 도착지가 모두 설정되어 있고, 클릭한 위치가 도착지와 같으면 경로 초기화
                            else if (startLocation && endLocation && isSameLocation(endLocation, {lat: markerLat, lng: markerLng})) {
                                clearRoute();
                            }
                        }, 50);
                    });
                    
                    bikeStationMarkers.push(marker);
                    bikeStationMarkerGroup.addLayer(marker);
                    
                    // 마커 주변 색상 영역 생성 (사용량 보기용)
                    // 마커 정보를 circle에 연결하기 위해 marker와 row 정보 전달
                    console.log('Creating circle for:', stationName, 'usageRate:', usageRate);
                    var circle = createUsageCircle(lat, lng, usageRate, marker, row, stationName);
                    if (circle) {
                        bikeStationCircles.push(circle);
                        console.log('Circle added to array:', stationName, 'total circles:', bikeStationCircles.length);
                    } else {
                        console.error('Failed to create circle for:', stationName);
                    }
                }
            });
            
            // 사용량 보기 체크 여부 확인
            var showUsageView = document.getElementById('show-usage-view') && document.getElementById('show-usage-view').checked;
            
            // 마커 그룹을 지도에 추가 (사용량 보기가 체크되어 있지 않을 때만)
            if (bikeStationMarkerGroup) {
                if (!showUsageView) {
                    // 사용량 보기가 체크되어 있지 않으면 마커 표시
                    if (!map.hasLayer(bikeStationMarkerGroup)) {
                        map.addLayer(bikeStationMarkerGroup);
                    }
                    // 색상 영역은 숨김
                    bikeStationCircles.forEach(function(circle) {
                        if (map.hasLayer(circle)) {
                            map.removeLayer(circle);
                        }
                    });
                } else {
                    // 사용량 보기가 체크되어 있으면 마커는 숨기고 색상 영역만 표시
                    if (map.hasLayer(bikeStationMarkerGroup)) {
                        map.removeLayer(bikeStationMarkerGroup);
                    }
                    bikeStationCircles.forEach(function(circle) {
                        if (!map.hasLayer(circle)) {
                            circle.addTo(map);
                            // circle이 지도에 추가되었는지 확인
                            console.log('Circle added to map:', circle.stationName, 'hasLayer:', map.hasLayer(circle));
                        }
                    });
                }
            }
            
            console.log('자전거 대여소 마커 표시 완료:', bikeStationMarkers.length, '개');
        }
        
        // 거치율에 따른 색상 영역 생성
        function createUsageCircle(lat, lng, usageRate, marker, row, stationName) {
            console.log('createUsageCircle called:', stationName, lat, lng, usageRate);
            // 거치율에 따라 색상 결정
            var usageLevel = Math.floor(usageRate / 10); // 0~10 사이의 값
            var opacity = 0.2 + (usageLevel * 0.08); // 0.2 ~ 1.0 사이 (10단위당 0.08 증가)
            
            // 거치율에 따라 색상 변경 (높을수록 분홍색, 낮을수록 초록색)
            var r, g, b;
            if (usageRate >= 50) {
                // 높은 거치율 (50% 이상): 분홍색 계열 (#F9035E)
                var intensity = (usageRate - 50) / 50; // 0~1 사이
                r = Math.floor(249 + (6 * intensity)); // 249~255
                g = Math.floor(3 - (3 * intensity)); // 3~0
                b = Math.floor(94 - (94 * intensity)); // 94~0
            } else {
                // 낮은 거치율 (50% 미만): 초록색 계열 (#A8F368)
                var intensity = usageRate / 50; // 0~1 사이
                r = Math.floor(168 - (119 * intensity)); // 168~249
                g = Math.floor(243 - (240 * intensity)); // 243~3
                b = Math.floor(104 - (10 * intensity)); // 104~94
            }
            
            // 임의의 크기 (거치율에 따라 약간 변동)
            var baseRadius = 30 + (usageLevel * 5); // 기본 30m + 거치율에 따라 증가
            var randomVariation = Math.random() * 20 - 10; // -10 ~ +10 랜덤 변동
            var radius = baseRadius + randomVariation;
            
            // 원형 영역 생성 (interactive: true로 설정하여 마우스 이벤트 활성화)
            var circle = L.circle([lat, lng], {
                radius: radius,
                fillColor: 'rgb(' + r + ', ' + g + ', ' + b + ')',
                color: 'rgb(' + r + ', ' + g + ', ' + b + ')',
                weight: 2,
                opacity: opacity,
                fillOpacity: opacity * 0.5,
                interactive: true, // 마우스 이벤트 활성화
                bubblingMouseEvents: false // 이벤트 버블링 방지
            });
            
            // 마커 정보를 circle에 저장
            circle.marker = marker;
            circle.stationData = row;
            circle.stationName = stationName;
            circle.usageRate = usageRate;
            
            // 팝업 내용 생성
            var popupContent = generateStationPopupContent(stationName, row);
            
            // 팝업 인스턴스 저장 (circle에 직접 저장)
            circle._usagePopup = null;
            
            // 마우스 오버 시 팝업 표시
            circle.on('mouseover', function(e) {
                var circleLayer = this;
                // 기존 팝업이 있으면 제거
                if (circleLayer._usagePopup) {
                    map.closePopup(circleLayer._usagePopup);
                }
                
                // 새 팝업 생성 및 표시
                circleLayer._usagePopup = L.popup({
                    maxWidth: 350,
                    className: 'usage-circle-popup',
                    closeButton: false,
                    autoClose: false,
                    closeOnClick: false,
                    closeOnEscapeKey: false
                })
                .setLatLng([lat, lng])
                .setContent(popupContent);
                
                circleLayer._usagePopup.openOn(map);
            });
            
            // 마우스 아웃 시 팝업 제거
            circle.on('mouseout', function(e) {
                var circleLayer = this;
                if (circleLayer._usagePopup) {
                    map.closePopup(circleLayer._usagePopup);
                    circleLayer._usagePopup = null;
                }
            });
            
            // 클릭 이벤트는 막기 (팝업이 닫히지 않도록)
            circle.on('click', function(e) {
                e.originalEvent.stopPropagation();
            });
            
            // circle이 지도에 추가된 후에도 이벤트가 작동하도록 확인
            circle.on('add', function() {
                console.log('Circle added to map:', stationName);
            });
            
            return circle;
        }
        
        // 대여소 정보 팝업 내용 생성 (마커 팝업과 동일한 형식)
        function generateStationPopupContent(stationName, row) {
            // 대여소 이름에서 넘버링 제거 (예: "465.삼청공원 앞" -> "삼청공원 앞")
            var displayName = String(stationName).replace(/^\d+\.\s*/, '').trim();
            
            var popupContent = '<div class="info">';
            popupContent += '<strong style="font-size: 16px; display: block; margin-bottom: 12px;">' + displayName + '</strong>';
            
            // 제외할 필드 목록
            var excludeFields = {
                'lat': true, 'LAT': true, 'stationLatitude': true, 'latitude': true,
                'lng': true, 'LNG': true, 'stationLongitude': true, 'longitude': true,
                'stationName': true, 'STATION_NAME': true, 'name': true,
                'rackTotCnt': true, 'RACK_TOT_CNT': true, 'rackTotalCnt': true,
                'parkingTotal': true, 'totalParking': true,
                'stationId': true, 'STATION_ID': true
            };
            
            // 모든 필드를 동적으로 표시
            var hasData = false;
            var fieldOrder = [];
            var fieldValues = {};
            
            for (var key in row) {
                if (row.hasOwnProperty(key) && !excludeFields[key]) {
                    var value = row[key];
                    if (value !== null && value !== undefined && value !== '') {
                        fieldOrder.push(key);
                        fieldValues[key] = value;
                        hasData = true;
                    }
                }
            }
            
            // 필드명을 한글이나 의미있는 이름으로 변환하는 함수
            function getFieldLabel(key) {
                if (/[가-힣]/.test(key)) {
                    return key;
                }
                
                var fieldMap = {
                    'parkingBikeTotCnt': '현재 자전거 수',
                    'PARKING_BIKE_TOT_CNT': '현재 자전거 수',
                    'parkingBikeTotalCnt': '현재 자전거 수',
                    'shared': '거치율',
                    'SHARED': '거치율',
                    'address': '주소',
                    'ADDRESS': '주소',
                    'district': '시군구',
                    'SIGNGU_NM': '시군구',
                    'gu': '구',
                    'stationLatitude': '위도',
                    'stationLongitude': '경도',
                    'stationName': '대여소명',
                    'STATION_NAME': '대여소명'
                };
                
                return fieldMap[key] || key;
            }
            
            // 값 포맷팅 함수
            function formatValue(key, value) {
                if (typeof value === 'number' || (!isNaN(value) && value !== '')) {
                    var numValue = parseFloat(value);
                    if (!isNaN(numValue)) {
                        if (numValue % 1 === 0) {
                            return numValue.toLocaleString();
                        }
                        return numValue.toLocaleString(undefined, { maximumFractionDigits: 2 });
                    }
                }
                return String(value);
            }
            
            // 필드를 표시
            if (hasData) {
                fieldOrder.forEach(function(key) {
                    var label = getFieldLabel(key);
                    var value = formatValue(key, fieldValues[key]);
                    
                    popupContent += '<div style="margin-bottom: 6px; padding-bottom: 6px; border-bottom: 1px solid #f0f0f0;">';
                    popupContent += '<span style="color: #666; font-size: 12px; display: inline-block; min-width: 100px;">' + label + ':</span> ';
                    popupContent += '<span style="color: #333; font-size: 13px; font-weight: 500;">' + value + '</span>';
                    popupContent += '</div>';
                });
            } else {
                popupContent += '<div style="color: #999; font-size: 12px;">추가 정보가 없습니다.</div>';
            }
            
            popupContent += '</div>';
            return popupContent;
        }
        
        // 사용량 보기 체크박스 변경 시 색상 영역 표시/숨김 및 마커 표시/숨김
        function updateMarkerColors() {
            var showUsageView = document.getElementById('show-usage-view') && document.getElementById('show-usage-view').checked;
            
            if (showUsageView) {
                // 사용량 보기 활성화: 마커 숨기고 색상 영역 표시
                if (bikeStationMarkerGroup && map.hasLayer(bikeStationMarkerGroup)) {
                    map.removeLayer(bikeStationMarkerGroup);
                }
                
                bikeStationCircles.forEach(function(circle) {
                    if (!map.hasLayer(circle)) {
                        circle.addTo(map);
                    }
                });
            } else {
                // 사용량 보기 비활성화: 색상 영역 숨기고 마커 표시
                bikeStationCircles.forEach(function(circle) {
                    if (map.hasLayer(circle)) {
                        map.removeLayer(circle);
                    }
                });
                
                if (bikeStationMarkerGroup && !map.hasLayer(bikeStationMarkerGroup)) {
                    map.addLayer(bikeStationMarkerGroup);
                }
            }
        }
        
        // 자전거 대여소 마커 제거
        function clearBikeStationMarkers() {
            if (bikeStationMarkerGroup) {
                map.removeLayer(bikeStationMarkerGroup);
                bikeStationMarkerGroup.clearLayers();
                bikeStationMarkerGroup = null;
            }
            bikeStationMarkers = [];
            
            // 색상 영역도 제거
            bikeStationCircles.forEach(function(circle) {
                if (map.hasLayer(circle)) {
                    map.removeLayer(circle);
                }
            });
            bikeStationCircles = [];
        }
        
        // 경로 찾기 기능 초기화
        function initRouteControls() {
            // 경로 초기화 버튼
            var clearBtn = document.getElementById('clear-route-btn');
            if (clearBtn) {
                clearBtn.addEventListener('click', function() {
                    clearRoute();
                });
            }
            
            // 통합 패널에서는 close 버튼이 없으므로 이벤트 리스너 제거
        }
        
        // 출발지 설정
        function setStartLocation(lat, lng, name, district) {
            startLocation = { lat: lat, lng: lng, name: name, district: district };
            updateRouteInfo();
            
            // 출발지 마커 표시
            if (startMarker) {
                map.removeLayer(startMarker);
            }
            startMarker = L.marker([lat, lng], {
                icon: L.divIcon({
                    className: 'route-marker route-start-marker',
                    html: '<div class="route-marker-inner">출발</div>',
                    iconSize: [60, 30],
                    iconAnchor: [30, 15]
                })
            }).addTo(map);
            
            // 도착지가 이미 설정되어 있으면 자동으로 경로 계산
            if (endLocation) {
                calculateRoute(startLocation, endLocation);
            }
        }
        
        // 도착지 설정
        function setEndLocation(lat, lng, name, district) {
            endLocation = { lat: lat, lng: lng, name: name, district: district };
            updateRouteInfo();
            
            // 도착지 마커 표시
            if (endMarker) {
                map.removeLayer(endMarker);
            }
            endMarker = L.marker([lat, lng], {
                icon: L.divIcon({
                    className: 'route-marker route-end-marker',
                    html: '<div class="route-marker-inner">도착</div>',
                    iconSize: [60, 30],
                    iconAnchor: [30, 15]
                })
            }).addTo(map);
            
            // 출발지가 이미 설정되어 있으면 자동으로 경로 계산
            if (startLocation) {
                calculateRoute(startLocation, endLocation);
            }
        }
        
        // 거치율 원형 그리드 생성 함수
        function createUsageGrid(usageRate) {
            var usageNum = parseFloat(usageRate);
            if (isNaN(usageNum)) return '';
            
            // 값이 1보다 작으면 퍼센테이지로 변환 (0.5 -> 50)
            if (usageNum <= 1 && usageNum > 0) {
                usageNum = usageNum * 100;
            }
            
            // 20개 원으로 표시 (각 원은 5%를 나타냄)
            var totalDots = 20;
            var filledCount = Math.min(Math.round(usageNum / 5), 20); // 100%까지는 20개
            var overCount = 0; // 100% 초과 개수
            
            if (usageNum > 100) {
                filledCount = 20; // 100%까지는 모두 채움
                overCount = Math.round((usageNum - 100) / 5); // 100% 초과분
            }
            
            var grid = '';
            
            // 10x2 그리드 생성 (20개 원)
            for (var i = 0; i < totalDots; i++) {
                if (i < filledCount) {
                    // 100% 이하: 주황색
                    grid += '<div class="usage-dot usage-dot-filled"></div>';
                } else {
                    // 나머지는 회색
                    grid += '<div class="usage-dot usage-dot-empty"></div>';
                }
            }
            
            // 100% 초과분은 분홍색으로 추가
            if (overCount > 0) {
                for (var i = 0; i < overCount; i++) {
                    grid += '<div class="usage-dot usage-dot-over"></div>';
                }
            }
            
            return grid;
        }
        
        // 대여소 정보 패널에 정보 표시
        function showStationInfo(stationName, row) {
            var infoContent = document.getElementById('station-info-content');
            
            if (!infoContent) return;
            
            // 대여소 이름에서 넘버링 제거 (예: "465.삼청공원 앞" -> "삼청공원 앞")
            var displayName = String(stationName).replace(/^\d+\.\s*/, '').trim();
            
            // 주요 데이터 추출
            var parkingBikeCnt = parseFloat(row.parkingBikeTotCnt || row.PARKING_BIKE_TOT_CNT || row.parkingBikeTotalCnt || 0);
            var rackTotCnt = parseFloat(row.rackTotCnt || row.RACK_TOT_CNT || row.rackTotalCnt || 0);
            var usageRate = rackTotCnt > 0 ? (parkingBikeCnt / rackTotCnt) * 100 : 0;
            var address = row.address || row.ADDRESS || '';
            var district = row.district || row.SIGNGU_NM || row.gu || '';
            
            // 패널 내용 생성 - 기하학적 그리드 디자인
            var content = '<div class="station-info-modern">';
            
            // 헤더 - 큰 원형 요소와 텍스트
            content += '<div class="station-header-minimal">';
            content += '<div class="header-circle header-circle-main"></div>';
            content += '<h2 class="station-name-title-minimal">' + displayName + '</h2>';
            if (district) {
                content += '<div class="station-location-minimal">' + district + '</div>';
            }
            content += '</div>';
            
            // 현재 자전거 수와 거치대 수를 나란히 배치
            content += '<div class="count-info-container">';
            // 현재 자전거 수 (큰 타이포 스타일)
            content += '<div class="bike-count-section">';
            content += '<div class="bike-count-value">' + parkingBikeCnt.toLocaleString() + '<span class="unit-text">대</span></div>';
            content += '<div class="bike-count-label">현재 자전거</div>';
            content += '</div>';
            
            // 거치대 수 (작은 스타일)
            content += '<div class="rack-count-section">';
            content += '<div class="rack-count-value">' + rackTotCnt.toLocaleString() + '<span class="unit-text">대</span></div>';
            content += '<div class="rack-count-label">거치대</div>';
            content += '</div>';
            content += '</div>';
            
            // 거치율 시각화 (원형 그리드)
            content += '<div class="usage-grid-section">';
            content += '<div class="usage-grid-header">';
            content += '<div class="usage-grid-percentage">' + usageRate.toFixed(0) + '%</div>';
            content += '<div class="usage-grid-description">현재 자전거 / 거치대</div>';
            content += '</div>';
            content += '<div class="usage-grid-container">' + createUsageGrid(usageRate) + '</div>';
            content += '</div>';
            
            // 주소 정보 (미니멀한 스타일)
            if (address) {
                content += '<div class="address-section-minimal">';
                content += '<div class="address-label-minimal">ADDRESS</div>';
                content += '<div class="address-value-minimal">' + address + '</div>';
                content += '</div>';
            }
            
            // 제외할 필드 목록
            var excludeFields = {
                'lat': true, 'LAT': true, 'stationLatitude': true, 'latitude': true,
                'lng': true, 'LNG': true, 'stationLongitude': true, 'longitude': true,
                'stationName': true, 'STATION_NAME': true, 'name': true,
                'rackTotCnt': true, 'RACK_TOT_CNT': true, 'rackTotalCnt': true,
                'parkingTotal': true, 'totalParking': true,
                'stationId': true, 'STATION_ID': true,
                'parkingBikeTotCnt': true, 'PARKING_BIKE_TOT_CNT': true, 'parkingBikeTotalCnt': true,
                'shared': true, 'SHARED': true,
                'address': true, 'ADDRESS': true,
                'district': true, 'SIGNGU_NM': true, 'gu': true
            };
            
            // 추가 정보 필드
            var hasAdditionalData = false;
            var additionalFields = [];
            
            for (var key in row) {
                if (row.hasOwnProperty(key) && !excludeFields[key]) {
                    var value = row[key];
                    if (value !== null && value !== undefined && value !== '') {
                        additionalFields.push({key: key, value: value});
                        hasAdditionalData = true;
                    }
                }
            }
            
            // 필드명을 한글이나 의미있는 이름으로 변환하는 함수
            function getFieldLabel(key) {
                if (/[가-힣]/.test(key)) {
                    return key;
                }
                
                var fieldMap = {
                    'parkingBikeTotCnt': '현재 자전거 수',
                    'PARKING_BIKE_TOT_CNT': '현재 자전거 수',
                    'parkingBikeTotalCnt': '현재 자전거 수',
                    'shared': '거치율',
                    'SHARED': '거치율',
                    'address': '주소',
                    'ADDRESS': '주소',
                    'district': '시군구',
                    'SIGNGU_NM': '시군구',
                    'gu': '구',
                    'stationLatitude': '위도',
                    'stationLongitude': '경도',
                    'stationName': '대여소명',
                    'STATION_NAME': '대여소명'
                };
                
                return fieldMap[key] || key;
            }
            
            // 값 포맷팅 함수
            function formatValue(key, value) {
                if (typeof value === 'number' || (!isNaN(value) && value !== '')) {
                    var numValue = parseFloat(value);
                    if (!isNaN(numValue)) {
                        if (numValue % 1 === 0) {
                            return numValue.toLocaleString();
                        }
                        return numValue.toLocaleString(undefined, { maximumFractionDigits: 2 });
                    }
                }
                return String(value);
            }
            
            // 자전거 아이콘 생성 함수 (다른 곳에서 사용할 수 있으므로 유지)
            function createBikeIcons(usageRate) {
                // 문자열에서 숫자만 추출 (예: "50%" -> 50)
                var usageNum = parseFloat(String(usageRate).replace(/[^0-9.-]/g, ''));
                if (isNaN(usageNum)) return '';
                
                // 값이 1보다 작으면 퍼센테이지로 변환 (0.5 -> 50)
                if (usageNum <= 1 && usageNum > 0) {
                    usageNum = usageNum * 100;
                }
                
                var icons = '';
                var greenCount = 0;
                var pinkCount = 0;
                
                if (usageNum <= 100) {
                    // 100 이하: 초록색 아이콘 개수 = 거치율 / 10 (반올림)
                    greenCount = Math.round(usageNum / 10);
                    // 나머지는 회색
                    for (var i = 0; i < 10; i++) {
                        if (i < greenCount) {
                            icons += '<span class="bike-icon bike-icon-green">🚲</span>';
                        } else {
                            icons += '<span class="bike-icon bike-icon-gray">🚲</span>';
                        }
                    }
                } else {
                    // 100 초과: 초록색 10개 + 분홍색 추가
                    greenCount = 10;
                    pinkCount = Math.round((usageNum - 100) / 10);
                    
                    // 초록색 10개
                    for (var i = 0; i < 10; i++) {
                        icons += '<span class="bike-icon bike-icon-green">🚲</span>';
                    }
                    // 분홍색 추가
                    for (var i = 0; i < pinkCount; i++) {
                        icons += '<span class="bike-icon bike-icon-pink">🚲</span>';
                    }
                }
                
                return '<span class="bike-icons-container">' + icons + '</span>';
            }
            
            // 추가 정보 표시
            if (hasAdditionalData) {
                content += '<div class="additional-info-section">';
                content += '<div class="additional-info-title">추가 정보</div>';
                additionalFields.forEach(function(field) {
                    var label = getFieldLabel(field.key);
                    var value = formatValue(field.key, field.value);
                    content += '<div class="additional-info-item">';
                    content += '<span class="additional-info-label">' + label + '</span>';
                    content += '<span class="additional-info-value">' + value + '</span>';
                    content += '</div>';
                });
                content += '</div>';
            }
            
            content += '</div>';
            
            // 패널 내용 업데이트
            infoContent.innerHTML = content;
            
            // 대여소 정보 섹션으로 스크롤
            var stationSection = infoContent.closest('.info-section');
            if (stationSection) {
                var panelContent = document.querySelector('.info-panel-content');
                if (panelContent) {
                    var sectionTop = stationSection.offsetTop;
                    panelContent.scrollTo({
                        top: sectionTop - 20,
                        behavior: 'smooth'
                    });
                }
            }
        }
        
        // 대여소 정보 패널 숨김 (통합 패널에서는 내용만 초기화)
        function hideStationInfo() {
            var infoContent = document.getElementById('station-info-content');
            if (infoContent) {
                infoContent.innerHTML = '<div class="station-info-placeholder">마커를 클릭하거나 사용량 영역에 마우스를 올리면 정보가 표시됩니다.</div>';
            }
        }
        
        // 경로 정보 업데이트
        function updateRouteInfo() {
            var startInfo = document.getElementById('route-start-info');
            var endInfo = document.getElementById('route-end-info');
            
            if (startInfo) {
                startInfo.textContent = '출발지: ' + (startLocation ? startLocation.name : '미설정');
            }
            if (endInfo) {
                endInfo.textContent = '도착지: ' + (endLocation ? endLocation.name : '미설정');
            }
        }
        
        /* ============================================
           따릉이 요금 계산 함수
           ============================================ */
        /**
         * 자전거 대여 요금 계산
         * @param {number} duration - 대여 시간 (분)
         * @returns {Object} 요금 정보 객체
         */
        function calculateBikeFare(duration) {
            if (!duration || duration <= 0) {
                return {
                    dailyFare: 0,
                    regularFare: 0,
                    overTime: 0
                };
            }
            
            var dailyFare = 0; // 일일권 요금
            var regularFare = 0; // 정기권 요금
            var overTime = 0; // 초과 시간 (분)
            
            // 일일권 요금 계산 (1시간권 기준)
            var dailyBaseTime = 60; // 기본 대여 시간: 1시간
            var dailyBaseFare = 1000; // 기본 요금: 1,000원
            
            if (duration <= dailyBaseTime) {
                // 기본 시간 이하: 기본 요금만
                dailyFare = dailyBaseFare;
                overTime = 0;
            } else {
                // 기본 시간 초과: 기본 요금 + 초과 시간 요금
                dailyFare = dailyBaseFare;
                overTime = duration - dailyBaseTime; // 기본 시간 초과분
                // 초과 시간 요금 계산 (5분마다 200원)
                var overTimeBlocks = Math.ceil(overTime / 5); // 5분 단위로 올림
                var overTimeFare = overTimeBlocks * 200;
                dailyFare += overTimeFare;
            }
            
            // 정기권 요금 계산 (1시간권 기준)
            var regularBaseTime = 60; // 기본 대여 시간: 1시간
            var regularBaseFare = 3000; // 기본 요금: 3,000원
            
            if (duration <= regularBaseTime) {
                // 기본 시간 이하: 기본 요금만
                regularFare = regularBaseFare;
                overTime = 0;
            } else {
                // 기본 시간 초과: 기본 요금 + 초과 시간 요금
                regularFare = regularBaseFare;
                overTime = duration - regularBaseTime; // 기본 시간 초과분
                // 초과 시간 요금 계산 (5분마다 200원)
                var overTimeBlocks = Math.ceil(overTime / 5); // 5분 단위로 올림
                var overTimeFare = overTimeBlocks * 200;
                regularFare += overTimeFare;
            }
            
            return {
                dailyFare: dailyFare,
                regularFare: regularFare,
                overTime: overTime
            };
        }
        
        // 경로 계산 (OSRM API 사용)
        function calculateRoute(start, end) {
            var infoContent = document.getElementById('route-info-content');
            
            // 로딩 메시지 표시
            if (infoContent) {
                infoContent.innerHTML = '<div class="route-info-loading">경로 계산 중...</div>';
            }
            
            // OSRM API 엔드포인트 (도보 경로)
            // OSRM의 foot 프로필은 도보 경로를 우선합니다
            // geometries=geojson으로 GeoJSON 형식 좌표 요청 ([lng, lat] 형식)
            var osrmUrl = 'https://router.project-osrm.org/route/v1/foot/' + 
                start.lng + ',' + start.lat + ';' + end.lng + ',' + end.lat + 
                '?overview=full&geometries=geojson&alternatives=false&steps=false';
            
            console.log('OSRM URL:', osrmUrl);
            
            // GraphHopper API 사용 (선택사항 - API 키가 있는 경우)
            var useGraphHopper = typeof GRAPHHOPPER_API_KEY !== 'undefined' && 
                                 GRAPHHOPPER_API_KEY !== '' && 
                                 GRAPHHOPPER_API_KEY !== 'YOUR_API_KEY';
            
            var apiUrl;
            if (useGraphHopper) {
                // GraphHopper 도보 경로
                apiUrl = 'https://graphhopper.com/api/1/route?' +
                    'point=' + start.lat + ',' + start.lng +
                    '&point=' + end.lat + ',' + end.lng +
                    '&vehicle=foot' +
                    '&key=' + GRAPHHOPPER_API_KEY +
                    '&type=json' +
                    '&instructions=false' +
                    '&calc_points=true' +
                    '&points_encoded=false';
            } else {
                apiUrl = osrmUrl;
            }
            
            fetch(apiUrl)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('경로를 찾을 수 없습니다.');
                    }
                    return response.json();
                })
                .then(function(data) {
                    var route, geometry, distance, duration;
                    
                    if (useGraphHopper && data.paths && data.paths.length > 0) {
                        // GraphHopper 응답 처리 (도보 경로)
                        route = data.paths[0];
                        // GraphHopper는 points_encoded=false일 때 GeoJSON 형식으로 반환
                        var coords = route.points.coordinates || route.points;
                        geometry = {
                            type: 'LineString',
                            coordinates: coords.map(function(coord) {
                                // GraphHopper는 [lng, lat] 형식이므로 [lat, lng]로 변환
                                return [coord[1], coord[0]];
                            })
                        };
                        distance = (route.distance / 1000).toFixed(2); // km
                        duration = Math.round(route.time / 1000 / 60); // 초를 분으로 변환
                    } else if (!useGraphHopper && data.code === 'Ok' && data.routes && data.routes.length > 0) {
                        // OSRM 응답 처리
                        route = data.routes[0];
                        
                        console.log('OSRM 전체 응답 data:', data);
                        console.log('OSRM route 객체:', route);
                        console.log('OSRM route.geometry:', route.geometry);
                        
                        // OSRM API는 geometries=geojson일 때 GeoJSON 형식으로 반환
                        // route.geometry는 GeoJSON LineString 객체: { type: 'LineString', coordinates: [[lng, lat], ...] }
                        if (route.geometry && route.geometry.type === 'LineString' && route.geometry.coordinates) {
                            geometry = route.geometry;
                            console.log('OSRM geometry (LineString) 확인됨');
                            console.log('OSRM geometry.coordinates 길이:', geometry.coordinates.length);
                            console.log('OSRM geometry.coordinates 샘플 (처음 3개):', geometry.coordinates.slice(0, 3));
                        } else {
                            console.error('OSRM 응답에서 geometry를 찾을 수 없습니다!');
                            console.log('route.geometry:', route.geometry);
                            console.log('route 전체 구조:', Object.keys(route));
                            throw new Error('경로 좌표를 찾을 수 없습니다.');
                        }
                        
                        distance = (route.distance / 1000).toFixed(2); // km
                        // 자전거 평균 속도로 시간 재계산 (약 15km/h)
                        // OSRM의 foot duration이 정확하지 않을 수 있으므로 거리 기반으로 계산
                        var bikeSpeedKmh = 15; // 자전거 평균 속도 (km/h)
                        var distanceKm = parseFloat(distance);
                        duration = Math.round((distanceKm / bikeSpeedKmh) * 60); // 분으로 변환
                    } else {
                        console.error('OSRM 응답 오류:', data);
                        throw new Error('경로를 찾을 수 없습니다.');
                    }
                    
                    // 경로 데이터 검증
                    console.log('경로 계산 완료, displayRoute 호출');
                    console.log('geometry:', geometry);
                    console.log('geometry.coordinates:', geometry ? geometry.coordinates : '없음');
                    console.log('geometry.coordinates 길이:', geometry && geometry.coordinates ? geometry.coordinates.length : 0);
                    
                    // geometry 객체 검증 (단계별로 상세하게)
                    if (!geometry) {
                        console.error('❌ geometry 객체가 없습니다!');
                        if (infoContent) {
                            infoContent.innerHTML = '<div class="route-info-error">경로 geometry를 가져올 수 없습니다.</div>';
                        }
                        return;
                    }
                    
                    // geometry.coordinates 존재 여부 확인
                    if (!geometry.coordinates) {
                        console.error('❌ geometry.coordinates가 없습니다!');
                        console.error('geometry 객체 전체:', JSON.stringify(geometry, null, 2));
                        console.error('geometry의 키들:', Object.keys(geometry));
                        if (infoContent) {
                            infoContent.innerHTML = '<div class="route-info-error">경로 좌표를 가져올 수 없습니다.</div>';
                        }
                        return;
                    }
                    
                    // geometry.coordinates가 배열인지 확인
                    if (!Array.isArray(geometry.coordinates)) {
                        console.error('❌ geometry.coordinates가 배열이 아닙니다!');
                        console.error('geometry.coordinates 타입:', typeof geometry.coordinates);
                        console.error('geometry.coordinates 값:', geometry.coordinates);
                        if (infoContent) {
                            infoContent.innerHTML = '<div class="route-info-error">경로 좌표 형식이 올바르지 않습니다.</div>';
                        }
                        return;
                    }
                    
                    // geometry.coordinates가 비어있는지 확인
                    if (geometry.coordinates.length === 0) {
                        console.error('❌ geometry.coordinates가 비어있습니다!');
                        if (infoContent) {
                            infoContent.innerHTML = '<div class="route-info-error">경로 좌표가 비어있습니다.</div>';
                        }
                        return;
                    }
                    
                    console.log('✅ 경로 좌표 검증 통과! 좌표 개수:', geometry.coordinates.length);
                    
                    // 경로 표시 (에러 처리 추가)
                    try {
                        displayRoute(geometry, route);
                    } catch (error) {
                        console.error('displayRoute 실행 중 오류:', error);
                        if (infoContent) {
                            infoContent.innerHTML = '<div class="route-info-error">경로 표시 중 오류가 발생했습니다: ' + error.message + '</div>';
                        }
                    }
                    
                    // 요금 계산
                    var fareInfo = calculateBikeFare(parseInt(duration));
                    
                    // 경로 정보 표시
                    if (infoContent) {
                        infoContent.innerHTML = 
                            '<div class="route-info-item">' +
                            '<div class="route-info-label">출발지</div>' +
                            '<div class="route-info-value">' + (start.name || '미설정') + '</div>' +
                            '</div>' +
                            '<div class="route-info-item">' +
                            '<div class="route-info-label">도착지</div>' +
                            '<div class="route-info-value">' + (end.name || '미설정') + '</div>' +
                            '</div>' +
                            '<div class="route-info-divider"></div>' +
                            '<div class="route-info-item">' +
                            '<div class="route-info-label">거리</div>' +
                            '<div class="route-info-value highlight">' + distance + ' km</div>' +
                            '</div>' +
                            '<div class="route-info-item">' +
                            '<div class="route-info-label">예상 시간</div>' +
                            '<div class="route-info-value highlight">' + duration + ' 분</div>' +
                            '</div>' +
                            '<div class="route-info-divider"></div>' +
                            '<div class="route-info-item">' +
                            '<div class="route-info-label">예상 요금 (일일권)</div>' +
                            '<div class="route-info-value highlight">' + fareInfo.dailyFare.toLocaleString() + '원</div>' +
                            '</div>' +
                            '<div class="route-info-item">' +
                            '<div class="route-info-label">예상 요금 (정기권)</div>' +
                            '<div class="route-info-value highlight">' + fareInfo.regularFare.toLocaleString() + '원</div>' +
                            '</div>' +
                            (fareInfo.overTime > 0 ? '<div class="route-info-note">* 초과 시간: ' + fareInfo.overTime + '분 (5분마다 200원 추가)</div>' : '');
                        
                        // 경로 정보 섹션으로 스크롤 이동 (패널 하단으로)
                        setTimeout(function() {
                            var panelContent = document.querySelector('.info-panel-content');
                            if (panelContent) {
                                // 패널의 스크롤을 맨 아래로 이동
                                panelContent.scrollTo({
                                    top: panelContent.scrollHeight,
                                    behavior: 'smooth'
                                });
                            }
                        }, 100);
                    }
                })
                .catch(function(error) {
                    console.error('경로 계산 오류:', error);
                    if (infoContent) {
                        infoContent.innerHTML = '<div class="route-info-error">경로를 찾을 수 없습니다.</div>';
                    }
                });
        }
        
        // 경로 표시
        function displayRoute(geometry, route) {
            try {
                console.log('=== displayRoute 함수 호출됨 ===');
                console.log('geometry:', geometry);
                console.log('route:', route);
                
                // geometry 검증
                if (!geometry) {
                    console.error('geometry가 없습니다!');
                    return;
                }
                
                // coordinates 검증 및 추출
                var coordinates = null;
                
                console.log('좌표 추출 시도 - geometry:', geometry);
                console.log('좌표 추출 시도 - route:', route);
                console.log('geometry.type:', geometry ? geometry.type : '없음');
                console.log('geometry.coordinates 존재:', geometry && geometry.coordinates ? '있음' : '없음');
                console.log('geometry.coordinates 타입:', geometry && geometry.coordinates ? typeof geometry.coordinates : '없음');
                console.log('geometry.coordinates 배열 여부:', geometry && geometry.coordinates ? Array.isArray(geometry.coordinates) : '없음');
                
                // 1. geometry.coordinates 확인 (OSRM의 경우 이것이 가장 일반적)
                if (geometry && geometry.coordinates && Array.isArray(geometry.coordinates) && geometry.coordinates.length > 0) {
                    coordinates = geometry.coordinates;
                    console.log('geometry.coordinates에서 좌표 추출 성공:', coordinates.length);
                    console.log('첫 번째 좌표 샘플:', coordinates[0]);
                } 
                // 2. route.geometry.coordinates 확인
                else if (route && route.geometry) {
                    console.log('route.geometry 확인:', route.geometry);
                    if (route.geometry.coordinates && Array.isArray(route.geometry.coordinates) && route.geometry.coordinates.length > 0) {
                        coordinates = route.geometry.coordinates;
                        console.log('route.geometry.coordinates에서 좌표 추출 성공:', coordinates.length);
                    } else if (route.geometry.type === 'LineString' && route.geometry.coordinates) {
                        coordinates = route.geometry.coordinates;
                        console.log('route.geometry (LineString)에서 좌표 추출 성공:', coordinates.length);
                    }
                }
                // 3. OSRM의 경우 legs에서 좌표 추출 (steps=false일 때는 사용 불가)
                else if (route && route.legs && route.legs.length > 0) {
                    console.log('route.legs 확인, legs 개수:', route.legs.length);
                    coordinates = [];
                    route.legs.forEach(function(leg) {
                        if (leg.steps) {
                            leg.steps.forEach(function(step) {
                                if (step.geometry && step.geometry.coordinates) {
                                    if (Array.isArray(step.geometry.coordinates[0])) {
                                        coordinates = coordinates.concat(step.geometry.coordinates);
                                    } else {
                                        coordinates.push(step.geometry.coordinates);
                                    }
                                }
                            });
                        }
                    });
                    if (coordinates.length > 0) {
                        console.log('route.legs에서 좌표 추출 성공:', coordinates.length);
                    } else {
                        console.warn('route.legs에서 좌표를 찾을 수 없습니다.');
                    }
                }
                
                if (!coordinates || !Array.isArray(coordinates) || coordinates.length === 0) {
                    console.error('경로 좌표를 찾을 수 없습니다!');
                    console.error('geometry 전체:', JSON.stringify(geometry, null, 2));
                    console.error('route 전체:', JSON.stringify(route, null, 2));
                    console.error('geometry.coordinates:', geometry ? geometry.coordinates : '없음');
                    console.error('route.geometry:', route ? route.geometry : '없음');
                    return;
                }
                
                console.log('좌표 추출 성공! 좌표 개수:', coordinates.length);
                console.log('첫 번째 좌표:', coordinates[0]);
                console.log('마지막 좌표:', coordinates[coordinates.length - 1]);
                
                console.log('추출된 좌표 개수:', coordinates.length);
                console.log('첫 번째 좌표:', coordinates[0]);
                
                // 기존 경로 제거
                if (routeLayer) {
                    try {
                        map.removeLayer(routeLayer);
                    } catch (e) {
                        console.warn('기존 경로 제거 중 오류:', e);
                    }
                }
                
                // 기존 자전거 애니메이션 중지
                stopRouteAnimation();
                
                // GeoJSON 형식의 좌표를 Leaflet 형식으로 변환
                // OSRM은 geometries=geojson일 때 [lng, lat] 형식으로 반환
                console.log('좌표 변환 시작, 원본 좌표 샘플:', coordinates.slice(0, 3));
                
                var latlngs = coordinates.map(function(coord, index) {
                    // coord가 [lng, lat] 형식인지 [lat, lng] 형식인지 확인
                    if (Array.isArray(coord) && coord.length >= 2) {
                        var first = coord[0];
                        var second = coord[1];
                        
                        // 유효한 좌표 범위 확인
                        if (typeof first !== 'number' || typeof second !== 'number' || 
                            isNaN(first) || isNaN(second)) {
                            if (index < 3) {
                                console.warn('유효하지 않은 좌표 (인덱스 ' + index + '):', coord);
                            }
                            return null;
                        }
                        
                        // OSRM GeoJSON은 [lng, lat] 형식이므로, 첫 번째 값이 경도 범위인지 확인
                        // 서울 지역: 경도 약 126-127, 위도 약 37-38
                        if (first >= -180 && first <= 180 && second >= -90 && second <= 90) {
                            // 첫 번째 값이 경도 범위이고, 서울 지역 좌표인 경우 [lng, lat] 형식으로 판단
                            if (first >= 120 && first <= 140 && second >= 30 && second <= 45) {
                                // [lng, lat] 형식이면 [lat, lng]로 변환
                                return [second, first];
                            } else if (first >= -180 && first <= 180) {
                                // 일반적으로 GeoJSON은 [lng, lat] 형식
                                return [second, first];
                            }
                        }
                        
                        // 이미 [lat, lng] 형식인 경우 (위도가 첫 번째)
                        if (first >= -90 && first <= 90 && second >= -180 && second <= 180) {
                            return [first, second];
                        }
                        
                        if (index < 3) {
                            console.warn('좌표 형식을 판단할 수 없음 (인덱스 ' + index + '):', coord);
                        }
                    }
                    return null;
                }).filter(function(coord) {
                    if (coord === null) return false;
                    // 유효한 좌표 범위 확인
                    var isValid = coord[0] >= -90 && coord[0] <= 90 && 
                                  coord[1] >= -180 && coord[1] <= 180;
                    if (!isValid && coord) {
                        console.warn('유효하지 않은 좌표 범위:', coord);
                    }
                    return isValid;
                });
                
                console.log('좌표 변환 완료, 변환된 좌표 샘플:', latlngs.slice(0, 3));
                
                console.log('변환된 좌표 개수:', latlngs.length);
                if (latlngs.length > 0) {
                    console.log('첫 번째 변환된 좌표:', latlngs[0]);
                }
                
                if (latlngs.length === 0) {
                    console.error('변환된 좌표가 없습니다!');
                    return;
                }
                
                // 경로 polyline 생성 (그라디언트 애니메이션 적용)
                try {
                    routeLayer = L.polyline(latlngs, {
                        color: '#F9035E', // 핑크색
                        weight: 5,
                        opacity: 0.8,
                        smoothFactor: 1,
                        pane: 'overlayPane', // 경로 라인은 overlayPane에 배치
                        className: 'route-line-gradient' // 그라디언트 클래스 추가
                    }).addTo(map);
                    
                    console.log('경로 라인 생성됨:', routeLayer);
                    
                    // SVG 그라디언트 정의 추가 (경로 라인에 그라디언트 애니메이션 적용)
                    setTimeout(function() {
                        var svg = map.getRenderer(routeLayer).container;
                        if (svg && svg.querySelector) {
                            // 기존 gradient 제거
                            var existingGradient = svg.querySelector('#routeGradient');
                            if (existingGradient) {
                                existingGradient.remove();
                            }
                            
                            // SVG defs 요소 찾기 또는 생성
                            var defs = svg.querySelector('defs');
                            if (!defs) {
                                defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                                svg.insertBefore(defs, svg.firstChild);
                            }
                            
                            // 그라디언트 정의 생성 (애니메이션 효과 포함)
                            var gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
                            gradient.setAttribute('id', 'routeGradient');
                            gradient.setAttribute('x1', '0%');
                            gradient.setAttribute('y1', '0%');
                            gradient.setAttribute('x2', '100%');
                            gradient.setAttribute('y2', '0%');
                            gradient.setAttribute('gradientUnits', 'userSpaceOnUse');
                            
                            // 그라디언트 중지점 생성 (핑크색 계열)
                            var stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                            stop1.setAttribute('offset', '0%');
                            stop1.setAttribute('stop-color', '#F9035E');
                            stop1.setAttribute('stop-opacity', '1');
                            
                            var stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                            stop2.setAttribute('offset', '50%');
                            stop2.setAttribute('stop-color', '#FF6B9D');
                            stop2.setAttribute('stop-opacity', '1');
                            
                            var stop3 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                            stop3.setAttribute('offset', '100%');
                            stop3.setAttribute('stop-color', '#F9035E');
                            stop3.setAttribute('stop-opacity', '1');
                            
                            // 그라디언트 애니메이션 (그라디언트가 경로를 따라 이동하는 효과)
                            var animate = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
                            animate.setAttribute('attributeName', 'x1');
                            animate.setAttribute('values', '0%;100%;0%');
                            animate.setAttribute('dur', '3s');
                            animate.setAttribute('repeatCount', 'indefinite');
                            gradient.appendChild(animate);
                            
                            var animate2 = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
                            animate2.setAttribute('attributeName', 'x2');
                            animate2.setAttribute('values', '100%;200%;100%');
                            animate2.setAttribute('dur', '3s');
                            animate2.setAttribute('repeatCount', 'indefinite');
                            gradient.appendChild(animate2);
                            
                            gradient.appendChild(stop1);
                            gradient.appendChild(stop2);
                            gradient.appendChild(stop3);
                            defs.appendChild(gradient);
                            
                            // 경로 라인의 path 요소에 그라디언트 적용
                            var path = routeLayer._path;
                            if (path) {
                                path.setAttribute('stroke', 'url(#routeGradient)');
                                path.setAttribute('stroke-width', '5');
                                path.setAttribute('stroke-opacity', '0.8');
                                path.setAttribute('fill', 'none');
                                path.setAttribute('stroke-linecap', 'round');
                                path.setAttribute('stroke-linejoin', 'round');
                            }
                            
                            console.log('경로 라인 그라디언트 애니메이션 적용 완료');
                        }
                    }, 100);
                    
                    // 경로 라인에서 좌표 추출 (네이게이션 경로 라인 활용)
                    var routeLatLngs = routeLayer.getLatLngs();
                    console.log('경로 라인에서 추출한 좌표 개수:', routeLatLngs.length);
                    
                    // 경로 좌표 저장 (경로 라인에서 직접 가져온 좌표 사용)
                    routeCoordinates = routeLatLngs.map(function(latlng) {
                        return [latlng.lat, latlng.lng];
                    });
                    currentRouteIndex = 0;
                    
                    console.log('routeCoordinates 저장됨 (경로 라인에서 추출), 길이:', routeCoordinates.length);
                    console.log('routeCoordinates 첫 번째 좌표:', routeCoordinates[0]);
                    
                    // 경로 좌표가 있는지 다시 확인
                    if (!routeCoordinates || routeCoordinates.length === 0) {
                        console.error('routeCoordinates가 비어있습니다!');
                        return;
                    }
                    
                    // 경로에 맞게 지도 범위 조정
                    try {
                        var bounds = routeLayer.getBounds();
                        if (bounds && bounds.isValid()) {
                            map.fitBounds(bounds, { padding: [50, 50] });
                        }
                    } catch (e) {
                        console.warn('지도 범위 조정 중 오류:', e);
                    }
                } catch (e) {
                    console.error('경로 라인 생성 중 오류:', e);
                    throw e;
                }
                
                // 자전거 애니메이션 시작 (경로 라인을 따라 이동)
                console.log('startRouteAnimation 호출 전');
                console.log('호출 전 routeCoordinates 길이:', routeCoordinates.length);
                try {
                    if (routeCoordinates && routeCoordinates.length > 0) {
                        startRouteAnimation();
                    } else {
                        console.error('startRouteAnimation 호출 전 routeCoordinates가 비어있습니다!');
                    }
                } catch (e) {
                    console.error('자전거 애니메이션 시작 중 오류:', e);
                    console.error('오류 발생 시 routeCoordinates:', routeCoordinates);
                    // 애니메이션 오류는 경로 표시를 막지 않음
                }
                console.log('startRouteAnimation 호출 후');
            } catch (error) {
                console.error('displayRoute 실행 중 오류:', error);
                console.error('오류 스택:', error.stack);
                throw error;
            }
        }
        
        // 경로를 따라 이동하는 자전거 애니메이션 시작
        function startRouteAnimation() {
            console.log('=== 자전거 애니메이션 시작 ===');
            console.log('routeCoordinates:', routeCoordinates);
            console.log('routeCoordinates 타입:', typeof routeCoordinates);
            console.log('routeCoordinates가 배열인가:', Array.isArray(routeCoordinates));
            console.log('routeCoordinates 길이:', routeCoordinates ? routeCoordinates.length : 'null/undefined');
            
            // 기존 애니메이션 중지
            stopRouteAnimation();
            
            // routeCoordinates 검증
            if (!routeCoordinates) {
                console.error('routeCoordinates가 정의되지 않았습니다!');
                return;
            }
            
            if (!Array.isArray(routeCoordinates)) {
                console.error('routeCoordinates가 배열이 아닙니다!', routeCoordinates);
                return;
            }
            
            if (routeCoordinates.length === 0) {
                console.error('경로 좌표가 없습니다! routeCoordinates:', routeCoordinates);
                return;
            }
            
            console.log('경로 좌표 검증 통과, 첫 번째 좌표:', routeCoordinates[0]);
            
            // 작은 원 아이콘 생성 (경로 라인을 따라 이동)
            var circleIconHtml = '<div class="route-circle-icon"></div>';
            var circleIcon = L.divIcon({
                className: 'route-circle-marker-container',
                html: circleIconHtml,
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });
            
            console.log('자전거 아이콘 생성:', bikeIcon);
            
            // 시작 위치에 작은 원 배치 (출발 지점)
            var startPos = routeCoordinates[0];
            console.log('시작 위치 (출발 지점):', startPos);
            
            try {
                routeBikeMarker = L.marker(startPos, {
                    icon: circleIcon,
                    zIndexOffset: 10000,
                    interactive: false,
                    riseOnHover: false,
                    bubblingMouseEvents: false
                });
                
                console.log('원 마커 객체 생성됨:', routeBikeMarker);
                
                routeBikeMarker.addTo(map);
                
                console.log('원 마커가 지도에 추가됨:', map.hasLayer(routeBikeMarker));
                
                // 마커가 제대로 표시되도록 강제 설정 (여러 번 시도)
                function forceShowMarker() {
                    if (routeBikeMarker) {
                        var markerEl = routeBikeMarker.getElement();
                        if (markerEl) {
                            markerEl.style.zIndex = '10000';
                            markerEl.style.position = 'absolute';
                            markerEl.style.display = 'block';
                            markerEl.style.visibility = 'visible';
                            markerEl.style.opacity = '1';
                            markerEl.style.pointerEvents = 'none';
                            
                            // 내부 div도 확인
                            var innerDiv = markerEl.querySelector('div');
                            if (innerDiv) {
                                innerDiv.style.display = 'block';
                                innerDiv.style.visibility = 'visible';
                                innerDiv.style.opacity = '1';
                                innerDiv.style.width = '16px';
                                innerDiv.style.height = '16px';
                            }
                            
                            console.log('마커 요소 확인:', markerEl);
                            console.log('마커 위치:', markerEl.style.left, markerEl.style.top);
                            console.log('마커 스타일:', window.getComputedStyle(markerEl).display);
                        } else {
                            console.error('마커 요소를 찾을 수 없음');
                        }
                    } else {
                        console.error('routeBikeMarker가 null입니다!');
                    }
                }
                
                // 즉시 실행
                forceShowMarker();
                // DOM 렌더링 후 다시 실행
                setTimeout(forceShowMarker, 10);
                setTimeout(forceShowMarker, 50);
                setTimeout(forceShowMarker, 100);
                setTimeout(forceShowMarker, 200);
                
                console.log('자전거 아이콘 생성 완료:', startPos, routeBikeMarker);
                
                // 애니메이션 시작
                currentRouteIndex = 0;
                animateBikeAlongRoute();
            } catch (error) {
                console.error('자전거 마커 생성 중 오류:', error);
            }
        }
        
        // 자전거가 경로를 따라 이동하는 애니메이션
        function animateBikeAlongRoute() {
            if (!routeBikeMarker || routeCoordinates.length === 0) {
                return;
            }
            
            // 경로의 끝에 도달했는지 확인
            if (currentRouteIndex >= routeCoordinates.length - 1) {
                // 도착 지점에 도달하면 마커 삭제
                if (routeBikeMarker) {
                    map.removeLayer(routeBikeMarker);
                    routeBikeMarker = null;
                }
                
                // 잠시 대기 후 다시 출발 지점에서 시작
                routeAnimationId = setTimeout(function() {
                    // 출발 지점에서 다시 시작
                    currentRouteIndex = 0;
                    startRouteAnimation();
                }, 500); // 0.5초 대기 후 재시작
                return;
            }
            
            // 다음 좌표로 이동
            var nextIndex = currentRouteIndex + 1;
            if (nextIndex < routeCoordinates.length) {
                var currentPos = routeCoordinates[currentRouteIndex];
                var nextPos = routeCoordinates[nextIndex];
                
                // 두 점 사이의 거리 계산
                var distance = map.distance(currentPos, nextPos);
                
                // 이동 속도 조절 (거리에 따라 시간 조정) - 매우 빠른 속도
                var speed = 500; // 픽셀/초 (200에서 500으로 증가 - 2.5배 더 빠름)
                var duration = Math.max(10, (distance / speed) * 10); // 최소 10ms (20ms에서 10ms로 감소)
                
                // 선형 보간으로 부드럽게 이동
                var steps = Math.max(2, Math.ceil(duration / 5)); // 더 빠른 프레임 (8ms에서 5ms로)
                var step = 0;
                
                function moveStep() {
                    step++;
                    if (step <= steps) {
                        var t = step / steps;
                        var lat = currentPos[0] + (nextPos[0] - currentPos[0]) * t;
                        var lng = currentPos[1] + (nextPos[1] - currentPos[1]) * t;
                        
                        if (routeBikeMarker) {
                            routeBikeMarker.setLatLng([lat, lng]);
                        }
                        
                        if (step < steps) {
                            routeAnimationId = requestAnimationFrame(moveStep);
                        } else {
                            // 다음 좌표로 이동
                            currentRouteIndex = nextIndex;
                            routeAnimationId = setTimeout(animateBikeAlongRoute, 10);
                        }
                    }
                }
                
                routeAnimationId = requestAnimationFrame(moveStep);
            }
        }
        
        // 경로 애니메이션 중지
        function stopRouteAnimation() {
            if (routeAnimationId) {
                if (typeof routeAnimationId === 'number') {
                    cancelAnimationFrame(routeAnimationId);
                    clearTimeout(routeAnimationId);
                }
                routeAnimationId = null;
            }
            
            if (routeBikeMarker) {
                map.removeLayer(routeBikeMarker);
                routeBikeMarker = null;
            }
            
            currentRouteIndex = 0;
            routeCoordinates = [];
        }
        
        // 경로 초기화
        function clearRoute() {
            // 경로 애니메이션 중지
            stopRouteAnimation();
            
            // 경로 레이어 제거
            if (routeLayer) {
                map.removeLayer(routeLayer);
                routeLayer = null;
            }
            
            // 마커 제거
            if (startMarker) {
                map.removeLayer(startMarker);
                startMarker = null;
            }
            if (endMarker) {
                map.removeLayer(endMarker);
                endMarker = null;
            }
            
            // 위치 초기화
            startLocation = null;
            endLocation = null;
            
            // 정보 업데이트
            updateRouteInfo();
            
            // 경로 정보 초기화
            var infoContent = document.getElementById('route-info-content');
            if (infoContent) {
                infoContent.innerHTML = '<div class="route-info-placeholder">경로를 계산하면 정보가 표시됩니다.</div>';
            }
        }
        
        // 마커 업데이트 (필터링)
        function updateMarkers() {
            // data.json 마커는 화면에서 숨김 (나중에 필요하면 다시 활성화 가능)
            console.log('updateMarkers called - data.json 마커는 현재 숨김 처리됨');
            return; // data.json 마커를 표시하지 않음
            
            // 아래 코드는 주석 처리 (나중에 필요하면 주석 해제)
            /*
            if (Object.keys(clusterGroupsByDistrict).length === 0) {
                console.warn('No cluster groups available');
                return;
            }
            
            var visibleDistricts = [];
            
            // 선택된 구 필터 수집
            document.querySelectorAll('.district-filter').forEach(function(checkbox) {
                if (checkbox.checked) {
                    visibleDistricts.push(checkbox.dataset.district);
                }
            });
            
            console.log('Visible districts:', visibleDistricts);
            console.log('Available cluster groups:', Object.keys(clusterGroupsByDistrict));
            console.log('Available markers by district:', Object.keys(markersByDistrict));
            
            // 먼저 모든 클러스터 그룹을 지도에서 제거하고 마커도 제거
            for (var district in clusterGroupsByDistrict) {
                if (clusterGroupsByDistrict.hasOwnProperty(district)) {
                    var clusterGroup = clusterGroupsByDistrict[district];
                    // 마커 먼저 제거
                    clusterGroup.clearLayers();
                    // 지도에서 레이어 제거
                    if (map.hasLayer(clusterGroup)) {
                        map.removeLayer(clusterGroup);
                        console.log('Removed cluster group from map for district:', district);
                    }
                }
            }
            
            // 출발지/도착지가 표시되는 구역에 있는지 확인
            var shouldClearRoute = false;
            if (startLocation && startLocation.district) {
                if (visibleDistricts.indexOf(startLocation.district) === -1) {
                    shouldClearRoute = true;
                }
            }
            if (endLocation && endLocation.district) {
                if (visibleDistricts.indexOf(endLocation.district) === -1) {
                    shouldClearRoute = true;
                }
            }
            
            // 출발지/도착지가 표시되지 않는 구역에 있으면 경로 초기화
            if (shouldClearRoute) {
                clearRoute();
            }
            
            // 선택된 구의 클러스터 그룹만 다시 추가
            visibleDistricts.forEach(function(district) {
                if (clusterGroupsByDistrict[district] && markersByDistrict[district] && markersByDistrict[district].length > 0) {
                    var clusterGroup = clusterGroupsByDistrict[district];
                    console.log('Processing district:', district, 'marker count:', markersByDistrict[district].length);
                    
                    // 클러스터 그룹이 지도에 있는지 확인하고 없으면 추가
                    if (!map.hasLayer(clusterGroup)) {
                        map.addLayer(clusterGroup);
                        console.log('Cluster group added to map for district:', district);
                    }
                    
                    // 마커 추가
                    try {
                        clusterGroup.addLayers(markersByDistrict[district]);
                        console.log('Markers added to cluster group for district:', district);
                        
                        // 잠시 후 마커가 제대로 추가되었는지 확인
                        setTimeout(function() {
                            var addedLayers = clusterGroup.getLayers();
                            console.log('Layers in cluster group for', district, ':', addedLayers.length);
                            if (addedLayers.length === 0) {
                                console.error('WARNING: No layers in cluster group for district:', district);
                                // 다시 시도
                                clusterGroup.addLayers(markersByDistrict[district]);
                            }
                        }, 200);
                    } catch (error) {
                        console.error('Error adding markers for district:', district, error);
                    }
                } else {
                    console.warn('Cannot add markers for district:', district, 
                        'clusterGroup exists:', !!clusterGroupsByDistrict[district],
                        'markers exist:', !!(markersByDistrict[district] && markersByDistrict[district].length > 0));
                }
            });
            
            // 자전거 대여소 마커도 업데이트
            if (allBikeStationData && allBikeStationData.length > 0) {
                updateBikeStationMarkers();
            }
            */
        }
        
        // 클릭한 위치에서 가장 가까운 마커 찾기
        function findNearestMarker(clickLat, clickLng) {
            if (!allMarkers || allMarkers.length === 0) {
                return null;
            }
            
            var nearestMarker = null;
            var minDistance = Infinity;
            
            allMarkers.forEach(function(marker) {
                var markerLat = marker.getLatLng().lat;
                var markerLng = marker.getLatLng().lng;
                
                // 두 점 사이의 거리 계산 (하버사인 공식)
                var R = 6371; // 지구 반지름 (km)
                var dLat = (markerLat - clickLat) * Math.PI / 180;
                var dLng = (markerLng - clickLng) * Math.PI / 180;
                var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                        Math.cos(clickLat * Math.PI / 180) * Math.cos(markerLat * Math.PI / 180) *
                        Math.sin(dLng / 2) * Math.sin(dLng / 2);
                var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                var distance = R * c;
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestMarker = marker;
                }
            });
            
            // 5km 이내의 마커만 반환 (너무 멀면 무시)
            if (minDistance <= 5) {
                return nearestMarker;
            }
            return null;
        }
        
        // 구 필터 체크
        function checkDistrictFilter(districtName) {
            var checkboxes = document.querySelectorAll('.district-filter');
            checkboxes.forEach(function(checkbox) {
                if (checkbox.dataset.district === districtName) {
                    checkbox.checked = true;
                    updateMarkers();
                }
            });
        }
        
        // 구 필터 토글 (체크되어 있으면 해제, 없으면 체크)
        function toggleDistrictFilter(districtName) {
            console.log('toggleDistrictFilter called for:', districtName);
            var checkboxes = document.querySelectorAll('.district-filter');
            var found = false;
            var targetCheckbox = null;
            
            checkboxes.forEach(function(checkbox) {
                if (checkbox.dataset.district === districtName) {
                    found = true;
                    targetCheckbox = checkbox;
                    checkbox.checked = !checkbox.checked;
                    console.log('Checkbox toggled:', districtName, 'checked:', checkbox.checked);
                }
            });
            
            if (found && targetCheckbox) {
                // change 이벤트 수동 트리거
                var changeEvent = new Event('change');
                targetCheckbox.dispatchEvent(changeEvent);
            } else {
                console.warn('Checkbox not found for district:', districtName);
            }
        }
        
        // 구역 하이라이트
        function highlightDistrict(districtName) {
            if (!districtFeatures[districtName]) {
                return;
            }
            
            // 기존 하이라이트 제거
            clearDistrictHighlight();
            
            // 새 하이라이트 추가
            hoverHighlightLayer = L.geoJSON(districtFeatures[districtName], {
                style: {
                    color: '#F9035E', // 핑크색
                    weight: 3,
                    opacity: 0.9,
                    fillOpacity: 0,
                    fillColor: '#F9035E' // 핑크색
                }
            }).addTo(map);
        }
        
        // 구역 하이라이트 제거
        function clearDistrictHighlight() {
            if (hoverHighlightLayer) {
                map.removeLayer(hoverHighlightLayer);
                hoverHighlightLayer = null;
            }
        }
        
        // 클릭한 위치가 속한 구역 찾기
        function findDistrictAtPoint(lat, lng) {
            if (typeof turf === 'undefined' || !turf.booleanPointInPolygon) {
                // turf.js가 없으면 가장 가까운 마커 사용
                var nearestMarker = findNearestMarker(lat, lng);
                if (nearestMarker && nearestMarker.options.district) {
                    return nearestMarker.options.district;
                }
                return null;
            }
            
            var point = turf.point([lng, lat]);
            
            // 각 구역 feature를 확인
            for (var districtName in districtFeatures) {
                if (districtFeatures.hasOwnProperty(districtName)) {
                    var feature = districtFeatures[districtName];
                    try {
                        if (turf.booleanPointInPolygon(point, feature)) {
                            return districtName;
                        }
                    } catch (error) {
                        console.warn('구역 검사 중 오류:', error);
                    }
                }
            }
            
            // 구역을 찾지 못하면 가장 가까운 마커 사용
            var nearestMarker = findNearestMarker(lat, lng);
            if (nearestMarker && nearestMarker.options.district) {
                return nearestMarker.options.district;
            }
            
            return null;
        }
        
        // 지도 클릭 이벤트 설정 (경계 레이어 클릭 이벤트가 있으므로 비활성화)
        function initMapClickHandler() {
            // 경계 레이어의 클릭 이벤트를 사용하므로 지도 클릭 이벤트는 비활성화
            // 경계 레이어가 없는 영역을 클릭할 때만 작동하도록 함
            var mapClickHandler = function(e) {
                // 경계 레이어 클릭 이벤트가 이미 처리했는지 확인
                // 경계 레이어 클릭은 stopPropagation을 호출하므로 여기까지 오지 않음
                // 하지만 혹시 모를 경우를 대비해 경계 레이어가 없는 영역만 처리
                var clickLat = e.latlng.lat;
                var clickLng = e.latlng.lng;
                
                // 클릭한 위치가 속한 구역 찾기
                var district = findDistrictAtPoint(clickLat, clickLng);
                
                if (district) {
                    toggleDistrictFilter(district);
                }
            };
            
            // 지도 클릭 이벤트는 주석 처리 (경계 레이어 클릭만 사용)
            // map.on('click', mapClickHandler);
            
            // 지도에 마우스 오버 시 커서 변경
            map.getContainer().style.cursor = 'pointer';
        }
        // DOM이 준비된 후 옵션 패널 초기화
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                initOptionsPanel();
            });
        } else {
            // DOM이 이미 준비된 경우
            initOptionsPanel();
        }
    </script>
</body>
</html>

