<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자전거 대여소 지도</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    
    <!-- Leaflet MarkerCluster CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"
          crossorigin=""/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"
          crossorigin=""/>
    
    <!-- Custom CSS -->
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="map"></div>

    <!-- 옵션 패널 -->
    <div id="options-panel">
        <div class="options-header" id="panel-header">
            <h3>마커 옵션</h3>
            <button id="toggle-panel" class="toggle-btn">−</button>
        </div>
        <div class="options-content">
            <div class="option-group">
                <div class="district-header" id="district-filter-header" style="cursor: pointer; user-select: none;">
                    <span>구별 필터</span>
                    <span class="district-toggle-icon" style="float: right; margin-left: 8px;">▶</span>
            </div>
                <div id="district-filters" class="district-filters" style="display: none;"></div>
            </div>
            <div class="option-group">
                <label style="display: flex; align-items: center; cursor: pointer; padding: 8px 0;">
                    <input type="checkbox" id="show-usage-view" style="margin-right: 8px;">
                    <span>사용량 보기</span>
                </label>
            </div>
        </div>
    </div>

    <!-- 경로 정보 팝업 패널 (좌측) -->
    <div id="route-info-panel" class="route-info-panel">
        <div class="route-info-header">
            <h3>경로 정보</h3>
            <button id="close-route-info" class="close-btn">×</button>
        </div>
        <div id="route-info-content" class="route-info-content">
            <div class="route-info-placeholder">경로를 계산하면 정보가 표시됩니다.</div>
        </div>
    </div>
    
    <!-- 대여소 정보 패널 (우측 하단) -->
    <div id="station-info-panel" class="station-info-panel">
        <div class="station-info-header">
            <h3>대여소 정보</h3>
            <button id="close-station-info" class="close-btn">×</button>
        </div>
        <div id="station-info-content" class="station-info-content">
            <div class="station-info-placeholder">마커를 클릭하거나 사용량 영역에 마우스를 올리면 정보가 표시됩니다.</div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    
    <!-- Leaflet MarkerCluster JS -->
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"
            crossorigin=""></script>
    
    <!-- Turf.js (GeoJSON 병합 및 단순화 용도) -->
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"
            crossorigin="anonymous"></script>
    
    <script>
        // Google Maps API 키 설정 (선택사항)
        // Google Maps를 사용하려면 아래 주석을 해제하고 YOUR_API_KEY를 실제 키로 변경하세요
        // var GOOGLE_MAPS_API_KEY = 'YOUR_API_KEY';
        
        // GraphHopper API 키 설정 (선택사항)
        // GraphHopper는 자전거 도로와 도보 경로를 더 정확하게 반영합니다
        // 무료 API 키는 https://www.graphhopper.com/api/ 에서 발급받을 수 있습니다
        // var GRAPHHOPPER_API_KEY = 'YOUR_API_KEY';
        
        // 서울시 공공자전거 대여소 사용 정보 API 키
        var SEOUL_BIKE_API_KEY = '4c6561716e746f7439376d6e4e6267';
        
        // CORS 프록시 설정 (HTTPS 페이지에서 HTTP API 호출 시 필요)
        // 공개 프록시 서비스를 사용하거나, 자신의 프록시 서버를 설정할 수 있습니다
        var USE_CORS_PROXY = true; // HTTPS 환경에서는 true로 설정
        
        // 사용 가능한 프록시 옵션 (여러 프록시를 순차적으로 시도)
        // 더 안정적인 프록시를 우선순위로 배치
        var CORS_PROXY_OPTIONS = [
            'https://api.codetabs.com/v1/proxy?quest=',
            'https://corsproxy.io/?',
            'https://cors-anywhere.herokuapp.com/'
        ];
        var currentProxyIndex = 0;
        var proxyFailures = {}; // 프록시별 실패 횟수 추적
        
        // API URL 생성 함수 (프록시 사용 여부에 따라 자동 처리)
        function getApiUrl(path) {
            var baseUrl = 'http://openapi.seoul.go.kr:8088/' + SEOUL_BIKE_API_KEY + path;
            // HTTPS 페이지에서 실행 중이면 프록시 사용
            var isHttps = window.location.protocol === 'https:' || 
                         window.location.hostname.includes('github.io') ||
                         window.location.hostname.includes('github.com');
            
            if (USE_CORS_PROXY && isHttps) {
                var proxyUrl = CORS_PROXY_OPTIONS[currentProxyIndex] + encodeURIComponent(baseUrl);
                // 로그 최소화 (성능 향상)
                return proxyUrl;
            }
            return baseUrl;
        }
        
        // 프록시 실패 시 다음 프록시로 전환
        function switchToNextProxy() {
            if (currentProxyIndex < CORS_PROXY_OPTIONS.length - 1) {
                var oldProxy = CORS_PROXY_OPTIONS[currentProxyIndex];
                proxyFailures[oldProxy] = (proxyFailures[oldProxy] || 0) + 1;
                currentProxyIndex++;
                console.warn('프록시 실패:', oldProxy, '-> 다음 프록시로 전환:', CORS_PROXY_OPTIONS[currentProxyIndex]);
            } else {
                console.error('모든 프록시를 시도했지만 실패했습니다. 페이지를 새로고침해주세요.');
                // 모든 프록시 실패 시 처음부터 다시 시도
                currentProxyIndex = 0;
            }
        }
        
        // 타임아웃이 포함된 fetch 래퍼
        function fetchWithTimeout(url, timeout) {
            timeout = timeout || 6000; // 기본 6초 타임아웃 (더 빠른 실패 처리)
            return Promise.race([
                fetch(url, {
                    method: 'GET',
                    mode: 'cors',
                    cache: 'no-cache',
                    headers: {
                        'Accept': 'application/json'
                    }
                }),
                new Promise(function(_, reject) {
                    setTimeout(function() {
                        reject(new Error('요청 시간 초과 (타임아웃: ' + timeout + 'ms)'));
                    }, timeout);
                })
            ]);
        }
        
        // 재시도 로직이 포함된 fetch 함수 (프록시 실패 시 자동 전환)
        function fetchWithRetry(url, retries, delay, originalPath) {
            retries = retries || 1; // 재시도 횟수 최소화 (2 -> 1)
            delay = delay || 300; // 재시도 딜레이 최소화 (500ms -> 300ms)
            originalPath = originalPath || null;
            
            return fetchWithTimeout(url, 6000) // 6초 타임아웃
            .then(function(response) {
                if (!response.ok) {
                    // 5xx 오류나 CORS 관련 오류인 경우 프록시 전환 시도
                    if ((response.status >= 500 || response.status === 0) && originalPath && USE_CORS_PROXY) {
                        switchToNextProxy();
                        var newUrl = getApiUrl(originalPath);
                        if (newUrl !== url) {
                            console.log('프록시 전환 후 재시도:', newUrl.substring(0, 80) + '...');
                            return fetchWithRetry(newUrl, retries, delay, originalPath);
                        }
                    }
                    throw new Error('HTTP ' + response.status + ': ' + response.statusText);
                }
                return response.json();
            })
            .catch(function(error) {
                var errorMsg = error.message || error.toString();
                // CORS 오류나 네트워크 오류인 경우 프록시 전환 시도 (재시도 전에 먼저 시도)
                if ((errorMsg.includes('CORS') || errorMsg.includes('Failed to fetch') || errorMsg.includes('NetworkError') || errorMsg.includes('ERR_')) 
                    && originalPath && USE_CORS_PROXY) {
                    // 현재 프록시가 실패했고 다른 프록시가 있으면 전환
                    if (currentProxyIndex < CORS_PROXY_OPTIONS.length - 1) {
                        switchToNextProxy();
                        var newUrl = getApiUrl(originalPath);
                        if (newUrl !== url) {
                            console.log('프록시 전환 후 즉시 재시도:', newUrl.substring(0, 80) + '...');
                            // 프록시 전환 시 재시도 횟수를 리셋하여 새 프록시로 다시 시도
                            return fetchWithRetry(newUrl, 1, 300, originalPath);
                        }
                    }
                }
                
                // 프록시 전환 실패 시 일반 재시도 (로그 제거로 성능 향상)
                if (retries > 0) {
                    return new Promise(function(resolve) {
                        setTimeout(function() {
                            resolve(fetchWithRetry(url, retries - 1, delay * 1.5, originalPath)); // 지수 백오프 완화 (2 -> 1.5)
                        }, delay);
                    });
                }
                throw error;
            });
        }
        
        // Google Maps 스타일 정의
        var mapStyle = [
            {
                "featureType": "all",
                "elementType": "geometry.fill",
                "stylers": [
                    {
                        "weight": "2.00"
                    }
                ]
            },
            {
                "featureType": "all",
                "elementType": "geometry.stroke",
                "stylers": [
                    {
                        "color": "#9c9c9c"
                    }
                ]
            },
            {
                "featureType": "all",
                "elementType": "labels.text",
                "stylers": [
                    {
                        "visibility": "on"
                    }
                ]
            },
            {
                "featureType": "landscape",
                "elementType": "all",
                "stylers": [
                    {
                        "color": "#f2f2f2"
                    }
                ]
            },
            {
                "featureType": "landscape",
                "elementType": "geometry.fill",
                "stylers": [
                    {
                        "color": "#ffffff"
                    }
                ]
            },
            {
                "featureType": "landscape.man_made",
                "elementType": "geometry.fill",
                "stylers": [
                    {
                        "color": "#ffffff"
                    }
                ]
            },
            {
                "featureType": "poi",
                "elementType": "all",
                "stylers": [
                    {
                        "visibility": "off"
                    }
                ]
            },
            {
                "featureType": "road",
                "elementType": "all",
                "stylers": [
                    {
                        "saturation": -100
                    },
                    {
                        "lightness": 45
                    }
                ]
            },
            {
                "featureType": "road",
                "elementType": "geometry.fill",
                "stylers": [
                    {
                        "color": "#eeeeee"
                    }
                ]
            },
            {
                "featureType": "road",
                "elementType": "labels.text.fill",
                "stylers": [
                    {
                        "color": "#7b7b7b"
                    }
                ]
            },
            {
                "featureType": "road",
                "elementType": "labels.text.stroke",
                "stylers": [
                    {
                        "color": "#ffffff"
                    }
                ]
            },
            {
                "featureType": "road.highway",
                "elementType": "all",
                "stylers": [
                    {
                        "visibility": "simplified"
                    }
                ]
            },
            {
                "featureType": "road.arterial",
                "elementType": "labels.icon",
                "stylers": [
                    {
                        "visibility": "off"
                    }
                ]
            },
            {
                "featureType": "transit",
                "elementType": "all",
                "stylers": [
                    {
                        "visibility": "off"
                    }
                ]
            },
            {
                "featureType": "water",
                "elementType": "all",
                "stylers": [
                    {
                        "color": "#46bcec"
                    },
                    {
                        "visibility": "on"
                    }
                ]
            },
            {
                "featureType": "water",
                "elementType": "geometry.fill",
                "stylers": [
                    {
                        "color": "#c8d7d4"
                    }
                ]
            },
            {
                "featureType": "water",
                "elementType": "labels.text.fill",
                "stylers": [
                    {
                        "color": "#070707"
                    }
                ]
            },
            {
                "featureType": "water",
                "elementType": "labels.text.stroke",
                "stylers": [
                    {
                        "color": "#ffffff"
                    }
                ]
            }
        ];

        // 서울 경계 설정 (대략적인 남서/북동 모서리)
        var seoulBounds = L.latLngBounds(
            [37.413294, 126.734086],
            [37.715133, 127.269311]
        );

        // 지도 초기화 (서울 중심, 서울 경계로 제한)
        var map = L.map('map', {
            maxBounds: seoulBounds,
            maxBoundsViscosity: 1.0,
            minZoom: 10,
            maxZoom: 40,
            zoomControl: true,
            preferCanvas: true
        }).fitBounds(seoulBounds);
        
        // 마커 클러스터 그룹 변수
        var markerClusterGroup = null; // 레거시 호환용
        var clusterGroupsByDistrict = {}; // 구별 클러스터 그룹 저장
        var seoulBoundaryLayer = null;
        var seoulBoundaryPolygon = null;
        var seoulMaskLayer = null;
        var baseTileLayer = null;
        var seoulBoundaryGeoJsonUrl = 'https://raw.githubusercontent.com/codeforamerica/click_that_hood/master/public/data/seoul.geojson';
        var clusterOnlyMaxZoom = 16; // 해당 줌 이하에서는 항상 클러스터로 표시
        var allMarkers = []; // 모든 마커 저장 (필터링용)
        var markersByDistrict = {}; // 구별 마커 저장
        var routeLayer = null; // 경로 표시 레이어
        var startMarker = null; // 출발지 마커
        var endMarker = null; // 도착지 마커
        var startLocation = null; // 출발지 좌표
        var endLocation = null; // 도착지 좌표
        var districtFeatures = {}; // 구별 GeoJSON feature 저장
        var hoverHighlightLayer = null; // 호버 하이라이트 레이어
        var bikeStationMarkers = []; // 자전거 대여소 마커 배열
        var bikeStationMarkerGroup = null; // 자전거 대여소 마커 그룹
        var bikeStationCircles = []; // 자전거 대여소 주변 색상 영역 배열
        var allBikeStationData = []; // 모든 자전거 대여소 데이터 저장
        var bikeStationCache = {}; // 지역별 필터링 결과 캐시
        var isDataLoaded = false; // 전체 데이터 로드 여부

        // 마스크용 커스텀 pane (타일 위, 경계선 아래)
        map.createPane('maskPane');
        map.getPane('maskPane').style.zIndex = 300;
        map.getPane('maskPane').style.pointerEvents = 'none';

        // 서울 시군구 이름 목록
        var seoulDistricts = [
            '강남구','강동구','강북구','강서구','관악구','광진구','구로구','금천구','노원구',
            '도봉구','동대문구','동작구','마포구','서대문구','서초구','성동구','성북구','송파구',
            '양천구','영등포구','용산구','은평구','종로구','중구','중랑구'
        ];
        var normalizedAllowedDistricts = seoulDistricts.map(normalizeDistrictName);

        // 맞춤형 마커 아이콘 (자전거 핀 형태)
        var bikeMarkerIcon = L.divIcon({
            className: '',
            html: '<div class="bike-marker"><div class="bike-marker__inner"></div></div>',
            iconSize: [34, 44],
            iconAnchor: [17, 42],
            popupAnchor: [0, -36],
            tooltipAnchor: [0, -30]
        });
        
        // 지도가 로드된 후 데이터 로드
        map.whenReady(function() {
            console.log('지도 로드 완료');
            loadSeoulBoundary()
                .then(function() {
                    loadMarkers();
                })
                .catch(function(error) {
                    console.error('경계 데이터를 불러오지 못했습니다. 그래도 데이터를 로드합니다.', error);
            loadMarkers();
                });
        });
        
        function loadSeoulBoundary() {
            return fetch(seoulBoundaryGeoJsonUrl)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('서울 경계 데이터를 불러오지 못했습니다: ' + response.status);
                    }
                    return response.json();
                })
                .then(function(geojson) {
                    if (seoulBoundaryLayer) {
                        map.removeLayer(seoulBoundaryLayer);
                        seoulBoundaryLayer = null;
                    }
                    var filteredGeojson = filterGeojsonByDistricts(geojson, normalizedAllowedDistricts);
                    var aggregatedGeojson = aggregateDistrictBoundaries(filteredGeojson, normalizedAllowedDistricts);
                    var boundarySource = (aggregatedGeojson && aggregatedGeojson.features && aggregatedGeojson.features.length) ? aggregatedGeojson : filteredGeojson;

                    var mergedBoundary = mergeFeaturesForMask(boundarySource);
                    seoulBoundaryPolygon = (mergedBoundary && mergedBoundary.features && mergedBoundary.features[0]) ? mergedBoundary.features[0] : null;

                    // 구역별 feature 저장
                    districtFeatures = {};
                    if (boundarySource && boundarySource.features) {
                        boundarySource.features.forEach(function(feature) {
                            var districtName = extractDistrictName(feature, normalizedAllowedDistricts);
                            if (districtName) {
                                districtFeatures[districtName] = feature;
                            }
                        });
                    }

                    // 경계 레이어용 pane 생성 (마스크 위에 표시)
                    if (!map.getPane('boundaryPane')) {
                        map.createPane('boundaryPane');
                        map.getPane('boundaryPane').style.zIndex = 400;
                    }
                    
                    seoulBoundaryLayer = L.geoJSON(boundarySource, {
                        pane: 'boundaryPane',
                        style: function(feature) {
                            return {
                                color: '#ffb703',
                                weight: 2,
                                opacity: 0.9,
                                fillOpacity: 0, // 기본 투명도 0
                                fillColor: '#ffb703',
                                interactive: true
                            };
                        },
                        onEachFeature: function(feature, layer) {
                            var districtName = extractDistrictName(feature, normalizedAllowedDistricts);
                            if (districtName) {
                                // 상호작용 명시적으로 활성화
                                layer.options.interactive = true;
                                
                                // 기본 스타일 저장
                                var defaultStyle = {
                                    fillOpacity: 0,
                                    fillColor: '#ffb703',
                                    weight: 2,
                                    color: '#ffb703'
                                };
                                
                                // 마우스 오버 이벤트
                                layer.on('mouseover', function(e) {
                                    console.log('Mouseover on district:', districtName);
                                    highlightDistrict(districtName);
                                    layer.setStyle({
                                        fillOpacity: 0,
                                        fillColor: '#4CAF50',
                                        weight: 3,
                                        color: '#4CAF50'
                                    });
                                });
                                
                                layer.on('mouseout', function(e) {
                                    console.log('Mouseout from district:', districtName);
                                    clearDistrictHighlight();
                                    layer.setStyle(defaultStyle);
                                });
                                
                                layer.on('click', function(e) {
                                    // 이벤트 전파 중지
                                    if (e.originalEvent) {
                                        e.originalEvent.stopPropagation();
                                        e.originalEvent.preventDefault();
                                    }
                                    L.DomEvent.stopPropagation(e);
                                    L.DomEvent.stop(e);
                                    
                                    // 클릭한 위치의 좌표로 정확한 구역 찾기
                                    var clickLat = e.latlng.lat;
                                    var clickLng = e.latlng.lng;
                                    var clickedDistrict = findDistrictAtPoint(clickLat, clickLng);
                                    
                                    // 찾은 구역이 있으면 그것을 사용, 없으면 레이어의 구역 사용
                                    var targetDistrict = clickedDistrict || districtName;
                                    
                                    console.log('Click on district layer:', districtName, 'clicked district:', clickedDistrict, 'using:', targetDistrict);
                                    toggleDistrictFilter(targetDistrict);
                                });
                                
                                // 초기 스타일 설정
                                layer.setStyle(defaultStyle);
                            }
                        }
                    }).addTo(map);

                    var boundaryBounds = seoulBoundaryLayer.getBounds();
                    if (boundaryBounds.isValid()) {
                        var paddedBounds = boundaryBounds.pad(0.01);
                        map.fitBounds(paddedBounds);
                        map.setMaxBounds(paddedBounds);
                        updateBaseTileLayer(paddedBounds);
                        applySeoulMask(seoulBoundaryPolygon, paddedBounds);
                    }

                })
                .catch(function(error) {
                    console.error('서울 경계선을 로드하는 중 오류 발생:', error);
                    throw error;
                });
        }

        function filterGeojsonByDistricts(geojson, normalizedWhitelist) {
            if (!geojson || !geojson.features || !geojson.features.length) {
                return geojson;
            }

            var filtered = geojson.features.filter(function(feature) {
                var props = feature.properties || {};
                var candidates = [
                    props.sggnm, props.SGGNM,
                    props.name, props.NAME,
                    props.adm_nm, props.ADM_NM
                ];
                return candidates.some(function(value) {
                    if (!value || typeof value !== 'string') {
                        return false;
                    }
                    var normalized = normalizeDistrictName(value);
                    return normalizedWhitelist.some(function(allowed) {
                        return normalized.indexOf(allowed) !== -1;
                    });
                });
            });

            if (!filtered.length) {
                return geojson;
            }

            return {
                type: 'FeatureCollection',
                features: filtered
            };
        }

        function aggregateDistrictBoundaries(geojson, normalizedWhitelist) {
            if (!geojson || !geojson.features || !geojson.features.length) {
                return geojson;
            }

            if (typeof turf === 'undefined' || !turf.union) {
                console.warn('Turf.js가 없어 구 경계 병합을 건너뜁니다.');
                return geojson;
            }

            var groups = {};
            geojson.features.forEach(function(feature) {
                var districtName = extractDistrictName(feature, normalizedWhitelist);
                if (!districtName) {
                    return;
                }
                if (!groups[districtName]) {
                    groups[districtName] = feature;
                } else {
                    try {
                        groups[districtName] = turf.union(groups[districtName], feature);
                    } catch (error) {
                        console.warn('구 경계 병합 중 오류 발생:', error);
                    }
                }
            });

            var aggregated = Object.keys(groups).map(function(name) {
                var mergedFeature = groups[name];
                if (!mergedFeature || !mergedFeature.geometry) {
                    return null;
                }
                mergedFeature.properties = mergedFeature.properties || {};
                mergedFeature.properties.districtName = name;
                return mergedFeature;
            }).filter(Boolean);

            if (!aggregated.length) {
                return geojson;
            }

            return {
                type: 'FeatureCollection',
                features: aggregated
            };
        }

        function mergeFeaturesForMask(geojson) {
            if (!geojson || !geojson.features || !geojson.features.length) {
                return null;
            }

            if (typeof turf === 'undefined' || !turf.union) {
                console.warn('Turf.js가 로드되지 않아 경계 병합을 건너뜁니다.');
                return geojson;
            }

            try {
                var merged = geojson.features[0];
                for (var i = 1; i < geojson.features.length; i++) {
                    merged = turf.union(merged, geojson.features[i]);
                }
                return {
                    type: 'FeatureCollection',
                    features: [merged]
                };
            } catch (error) {
                console.warn('서울 경계를 병합하는 중 오류가 발생했습니다. 원본 데이터를 사용합니다.', error);
                return geojson;
            }
        }

        function extractDistrictName(feature, normalizedWhitelist) {
            if (!feature || !feature.properties) {
                return null;
            }
            
            // aggregateDistrictBoundaries에서 추가한 districtName 속성 확인
            if (feature.properties.districtName) {
                return feature.properties.districtName;
            }
            
            var candidates = [
                feature.properties.sggnm, feature.properties.SGGNM,
                feature.properties.name, feature.properties.NAME,
                feature.properties.adm_nm, feature.properties.ADM_NM
            ];

            for (var i = 0; i < candidates.length; i++) {
                var value = candidates[i];
                if (!value || typeof value !== 'string') {
                    continue;
                }
                var normalized = normalizeDistrictName(value);
                for (var j = 0; j < normalizedWhitelist.length; j++) {
                    var allowed = normalizedWhitelist[j];
                    if (normalized.indexOf(allowed) !== -1) {
                        return seoulDistricts[j];
                    }
                }
            }
            return null;
        }

        function normalizeDistrictName(name) {
            if (!name) {
                return '';
            }
            return String(name).replace(/\s+/g, '').replace(/[^가-힣A-Za-z0-9]/g, '');
        }

        function applySeoulMask(polygonFeature, bounds) {
            if (!polygonFeature || !polygonFeature.geometry) {
                return;
            }

            if (seoulMaskLayer) {
                map.removeLayer(seoulMaskLayer);
                seoulMaskLayer = null;
            }

            var padding = 5;
            var outer = [
                [bounds.getNorthEast().lat + padding, bounds.getSouthWest().lng - padding],
                [bounds.getNorthEast().lat + padding, bounds.getNorthEast().lng + padding],
                [bounds.getSouthWest().lat - padding, bounds.getNorthEast().lng + padding],
                [bounds.getSouthWest().lat - padding, bounds.getSouthWest().lng - padding]
            ];

            var rings = extractPolygonRings(polygonFeature);
            if (!rings.length) {
                return;
            }

            seoulMaskLayer = L.polygon([outer].concat(rings), {
                color: '#f2f2f2',
                weight: 0,
                fillColor: '#f2f2f2',
                fillOpacity: 1,
                interactive: false,
                pane: 'maskPane'
            }).addTo(map);
        }

        function extractPolygonRings(feature) {
            var rings = [];
            if (!feature || !feature.geometry || !feature.geometry.coordinates) {
                return rings;
            }

            var coords = feature.geometry.coordinates;
            if (feature.geometry.type === 'Polygon') {
                coords.forEach(function(ring) {
                    rings.push(ring.map(function(coord) {
                        return [coord[1], coord[0]];
                    }));
                });
            } else if (feature.geometry.type === 'MultiPolygon') {
                coords.forEach(function(poly) {
                    poly.forEach(function(ring) {
                        rings.push(ring.map(function(coord) {
                            return [coord[1], coord[0]];
                        }));
                    });
                });
            }
            return rings;
        }

        function updateBaseTileLayer(bounds) {
            if (baseTileLayer) {
                map.removeLayer(baseTileLayer);
                baseTileLayer = null;
            }
            baseTileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                attribution: '© OpenStreetMap contributors © CARTO',
                subdomains: 'abcd',
                minZoom: 10,
                maxZoom: 40,
                bounds: bounds,
                noWrap: true,
                keepBuffer: 1,
                updateWhenIdle: true,
                updateWhenZooming: false
            });
            baseTileLayer.addTo(map);
        }

        function isLocationInSeoul(location) {
            if (!location) {
                return false;
            }
            var lat = parseFloat(location.lat);
            var lng = parseFloat(location.lng);
            if (!(lat && lng) || isNaN(lat) || isNaN(lng) ||
                lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                return false;
            }

            if (seoulBoundaryPolygon && typeof turf !== 'undefined' && turf.booleanPointInPolygon) {
                var point = turf.point([lng, lat]);
                try {
                    if (turf.booleanPointInPolygon(point, seoulBoundaryPolygon)) {
                        return true;
                    }
                } catch (error) {
                    console.warn('경계 다각형 검사 중 오류:', error);
                }
            }

            if (location.CTPRVN_NM && location.CTPRVN_NM.indexOf('서울') !== -1) {
                return true;
            }
            if (location.FCLTY_ROAD_NM_ADDR && location.FCLTY_ROAD_NM_ADDR.indexOf('서울특별시') !== -1) {
                return true;
            }
            if (location.SIGNGU_NM && seoulDistricts.indexOf(location.SIGNGU_NM) !== -1) {
                return true;
            }
            return seoulBounds.contains([lat, lng]);
        }
        
        function loadMarkers() {
        
        // Google Maps API 키가 있는 경우 아래 주석을 해제하여 Google Maps 스타일을 사용할 수 있습니다
        /*
        if (typeof GOOGLE_MAPS_API_KEY !== 'undefined' && GOOGLE_MAPS_API_KEY !== 'YOUR_API_KEY') {
            // Google Maps API 스크립트 동적 로드
            var script = document.createElement('script');
            script.src = 'https://maps.googleapis.com/maps/api/js?key=' + GOOGLE_MAPS_API_KEY + '&libraries=geometry&callback=initGoogleMap';
            document.head.appendChild(script);
            
            // Leaflet Google Mutant Plugin 로드
            var mutantScript = document.createElement('script');
            mutantScript.src = 'https://unpkg.com/leaflet.gridlayer.googlemutant@latest/dist/Leaflet.GoogleMutant.js';
            mutantScript.onload = function() {
                window.initGoogleMap = function() {
                    var googleLayer = L.gridLayer.googleMutant({
                        type: 'roadmap',
                        styles: mapStyle
                    });
                    map.removeLayer(map._layers[Object.keys(map._layers)[0]]); // 기존 타일 제거
                    googleLayer.addTo(map);
                };
            };
            document.head.appendChild(mutantScript);
        }

        */

            // data.json 파일 로드 (CORS 문제 해결: fetch와 XMLHttpRequest 모두 시도)
            function processData(data) {
                console.log('데이터 로드 성공:', data.length, '개 항목');
                
                var filteredData = data.filter(isLocationInSeoul);
                console.log('서울 데이터 필터링:', filteredData.length, '개 항목');
                
                // 모든 마커를 저장할 배열
                var markers = [];
                var invalidCount = 0;
                
                // 각 위치에 마커 추가
                filteredData.forEach(function(location, index) {
                    // 위도와 경도 확인 (업데이트된 JSON 구조: lat, lng 사용)
                    var lat = parseFloat(location.lat);
                    var lng = parseFloat(location.lng);
                    
                    // 유효한 좌표인지 확인 (0이 아니고, 숫자이고, 유효한 범위 내)
                    if (lat && lng && !isNaN(lat) && !isNaN(lng) && 
                        lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
                        // Tooltip 내용 구성 (마우스 오버 시 표시)
                        var tooltipContent = '<div style="font-weight: bold; margin-bottom: 3px;">' + 
                            (location.FCLTY_NM || '자전거 대여소') + '</div>';
                        if (location.SIGNGU_NM) {
                            tooltipContent += '<div style="font-size: 12px; color: #ddd;">' + location.SIGNGU_NM + '</div>';
                        }
                        
                        // 마커 생성 (아직 지도에 추가하지 않음)
                        var district = location.SIGNGU_NM || '기타';
                        var marker = L.marker([lat, lng], { 
                            icon: bikeMarkerIcon,
                            district: district,
                            locationData: location // 위치 데이터 저장
                        })
                            .bindTooltip(tooltipContent, {
                                permanent: false,
                                direction: 'top',
                                className: 'custom-tooltip',
                                offset: [0, -10]
                            });
                        
                        // Popup 내용을 함수로 생성 (팝업이 열릴 때마다 최신 내용 생성)
                        marker.bindPopup(function() {
                            var popupContent = '<div class="info">';
                            popupContent += '<strong style="font-size: 16px; display: block; margin-bottom: 8px;">' + 
                                (location.FCLTY_NM || '자전거 대여소') + '</strong>';
                            
                            if (location.LCLAS_NM) {
                                popupContent += '<div style="margin-bottom: 5px;"><span style="color: #666;">시설분류:</span> ' + 
                                    location.LCLAS_NM + '</div>';
                            }
                            
                            if (location.FCLTY_ROAD_NM_ADDR) {
                                popupContent += '<div style="margin-bottom: 5px;"><span style="color: #666;">주소:</span><br>' + 
                                    location.FCLTY_ROAD_NM_ADDR + '</div>';
                            }
                            
                            if (location.SIGNGU_NM) {
                                popupContent += '<div style="margin-bottom: 5px;"><span style="color: #666;">시군구:</span> ' + 
                                    location.SIGNGU_NM + '</div>';
                            }
                            
                            if (location.LEGALDONG_NM) {
                                popupContent += '<div style="margin-bottom: 5px;"><span style="color: #666;">법정동:</span> ' + 
                                    location.LEGALDONG_NM + '</div>';
                            }
                            
                            if (location.BULD_NM) {
                                popupContent += '<div style="margin-bottom: 5px;"><span style="color: #666;">건물명:</span> ' + 
                                    location.BULD_NM + '</div>';
                            }
                            
                            if (location.CTPRVN_NM) {
                                popupContent += '<div style="margin-bottom: 5px;"><span style="color: #666;">시도:</span> ' + 
                                    location.CTPRVN_NM + '</div>';
                            }
                            
                            if (location.MLSFC_NM) {
                                popupContent += '<div style="margin-bottom: 5px;"><span style="color: #666;">상세분류:</span> ' + 
                                    location.MLSFC_NM + '</div>';
                            }
                            
                            if (location.ADDR_ENG_NM) {
                                popupContent += '<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #eee; font-size: 12px; color: #888;">' + 
                                    location.ADDR_ENG_NM + '</div>';
                            }
                            
                            popupContent += '</div>';
                            return popupContent;
                        }, {
                            maxWidth: 300
                        });
                        
                        // 마커 클릭 이벤트: 자동으로 출발지/도착지 설정
                        marker.on('click', function(e) {
                            // 팝업 버튼 클릭과 구분하기 위해 약간의 지연
                            setTimeout(function() {
                                var markerLat = marker.getLatLng().lat;
                                var markerLng = marker.getLatLng().lng;
                                var markerName = location.FCLTY_NM || '자전거 대여소';
                                var markerDistrict = district; // 구역 정보
                                
                                // 출발지와 도착지가 모두 설정되어 있으면 기존 경로 초기화
                                if (startLocation && endLocation) {
                                    clearRoute();
                                }
                                
                                // 출발지가 없으면 출발지로 설정
                                if (!startLocation) {
                                    setStartLocation(markerLat, markerLng, markerName, markerDistrict);
                                }
                                // 출발지가 있고 도착지가 없으면 도착지로 설정
                                else if (!endLocation) {
                                    setEndLocation(markerLat, markerLng, markerName, markerDistrict);
                                }
                            }, 50);
                        });
                        
                        
                        markers.push(marker);
                        
                        // 구별 마커 저장
                        if (!markersByDistrict[district]) {
                            markersByDistrict[district] = [];
                        }
                        markersByDistrict[district].push(marker);
                    } else {
                        invalidCount++;
                        if (index < 5) { // 처음 5개만 로그
                            console.warn('유효하지 않은 좌표:', index, location);
                        }
                    }
                });

                console.log('유효한 마커:', markers.length, '개');
                console.log('유효하지 않은 데이터:', invalidCount, '개');

                // 기존 클러스터 그룹 제거
                for (var district in clusterGroupsByDistrict) {
                    if (clusterGroupsByDistrict.hasOwnProperty(district)) {
                        map.removeLayer(clusterGroupsByDistrict[district]);
                    }
                }
                clusterGroupsByDistrict = {};
                
                if (markerClusterGroup) {
                    map.removeLayer(markerClusterGroup);
                    markerClusterGroup = null;
                }

                if (markers.length > 0) {
                        // 전체 마커 배열 저장
                        allMarkers = markers.slice();
                        
                        // 구별로 클러스터 그룹 생성
                        for (var district in markersByDistrict) {
                            if (markersByDistrict.hasOwnProperty(district) && markersByDistrict[district].length > 0) {
                                var clusterGroup = L.markerClusterGroup({
                                    showCoverageOnHover: false,
                                    maxClusterRadius: 95,
                                    spiderfyOnMaxZoom: false,
                                    disableClusteringAtZoom: clusterOnlyMaxZoom + 1,
                                    removeOutsideVisibleBounds: false, // 화면 밖 마커도 유지
                                    iconCreateFunction: function(cluster) {
                                        var count = cluster.getChildCount();
                                        var sizeClass = 'cluster-small';
                                        if (count >= 50) {
                                            sizeClass = 'cluster-large';
                                        } else if (count >= 20) {
                                            sizeClass = 'cluster-medium';
                                        }
                                        return L.divIcon({
                                            html: '<div class="bike-cluster ' + sizeClass + '"><span>' + count + '</span></div>',
                                            className: '',
                                            iconSize: [48, 48],
                                            iconAnchor: [24, 24]
                                        });
                                    }
                                });
                                
                                // 클러스터 그룹 생성 (마커는 나중에 updateMarkers에서 추가)
                                clusterGroupsByDistrict[district] = clusterGroup;
                                
                                // 클러스터 그룹은 지도에 추가하지 않음 (updateMarkers에서 필요할 때만 추가)
                            }
                        }
                        
                        // 레거시 호환을 위한 단일 클러스터 그룹 (사용하지 않지만 참조용)
                        markerClusterGroup = {
                            clearLayers: function() {
                                for (var d in clusterGroupsByDistrict) {
                                    if (clusterGroupsByDistrict.hasOwnProperty(d)) {
                                        clusterGroupsByDistrict[d].clearLayers();
                                    }
                                }
                            },
                            addLayers: function(markerArray) {
                                // 구별로 분류하여 해당 클러스터 그룹에 추가
                                var markersByDist = {};
                                markerArray.forEach(function(marker) {
                                    var dist = marker.options.district;
                                    if (!markersByDist[dist]) {
                                        markersByDist[dist] = [];
                                    }
                                    markersByDist[dist].push(marker);
                                });
                                
                                for (var dist in markersByDist) {
                                    if (clusterGroupsByDistrict[dist]) {
                                        clusterGroupsByDistrict[dist].addLayers(markersByDist[dist]);
                                    }
                                }
                            }
                        };

                    // 모든 마커를 포함하는 범위 계산
                    var group = new L.featureGroup(markers);
                    map.fitBounds(group.getBounds().pad(0.1));
                    var currentZoom = map.getZoom();
                    if (currentZoom > clusterOnlyMaxZoom) {
                        map.setZoom(clusterOnlyMaxZoom);
                    }
                    console.log('지도 범위 조정 완료');
                    
                    // 초기 상태: 마커 표시 안 함 (옵션 패널 설정에 따라)
                    updateMarkers();
                    
                    // 지도 클릭 이벤트 초기화
                    initMapClickHandler();
                } else {
                    console.error('표시할 마커가 없습니다. 데이터를 확인해주세요.');
                    alert('표시할 마커가 없습니다. 브라우저 콘솔을 확인해주세요.');
                }
            }
            
            function handleError(error, method) {
                console.error('데이터를 불러오는 중 오류가 발생했습니다 (' + method + '):', error);
                var errorMsg = '데이터를 불러올 수 없습니다.\n\n';
                errorMsg += '가능한 원인:\n';
                errorMsg += '1. CORS 정책 (file:// 프로토콜 사용 시)\n';
                errorMsg += '2. data.json 파일이 같은 폴더에 없음\n';
                errorMsg += '3. 파일 경로 오류\n\n';
                errorMsg += '해결 방법:\n';
                errorMsg += '로컬 웹 서버를 사용하세요:\n';
                errorMsg += '- Python: python -m http.server 8000\n';
                errorMsg += '- Node.js: npx http-server\n';
                errorMsg += '그 후 http://localhost:8000/index.html 접속\n\n';
                errorMsg += '에러: ' + (error.message || error);
                alert(errorMsg);
            }
            
            // 먼저 fetch 시도 (HTTP 서버 사용 시)
            fetch('data.json')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('HTTP error! status: ' + response.status);
                    }
                    return response.json();
                })
                .then(data => {
                    processData(data);
                })
                .catch(fetchError => {
                    // fetch 실패 시 XMLHttpRequest 시도 (file:// 프로토콜 대응)
                    console.warn('fetch 실패, XMLHttpRequest로 재시도:', fetchError);
                    var xhr = new XMLHttpRequest();
                    xhr.open('GET', 'data.json', true);
                    xhr.onreadystatechange = function() {
                        if (xhr.readyState === 4) {
                            if (xhr.status === 200 || xhr.status === 0) { // 0은 file:// 프로토콜에서 성공
                                try {
                                    var data = JSON.parse(xhr.responseText);
                                    processData(data);
                                } catch (parseError) {
                                    handleError(parseError, 'XMLHttpRequest (JSON 파싱)');
                                }
                            } else {
                                handleError(new Error('HTTP status: ' + xhr.status), 'XMLHttpRequest');
                            }
                        }
                    };
                    xhr.onerror = function() {
                        handleError(new Error('Network error'), 'XMLHttpRequest');
                    };
                    xhr.send(null);
                });
        }
        
        // 옵션 패널 초기화
        function initOptionsPanel() {
            var districtFilters = document.getElementById('district-filters');
            
            // 이미 초기화되었으면 체크박스만 업데이트
            if (districtFilters.children.length === 0) {
                seoulDistricts.forEach(function(district) {
                    var label = document.createElement('label');
                    label.className = 'district-checkbox';
                    label.innerHTML = '<input type="checkbox" class="district-filter" data-district="' + district + '"> ' + district;
                    districtFilters.appendChild(label);
                });
                
                // 구별 필터 체크박스 이벤트 리스너
                document.querySelectorAll('.district-filter').forEach(function(checkbox) {
                    checkbox.addEventListener('change', function(e) {
                        // 다중 선택 모드: 여러 지역을 동시에 선택 가능
                        updateMarkers();
                        // 자전거 대여소 마커도 업데이트 (지역 선택 시마다 API 호출)
                        updateBikeStationMarkers();
                    });
                });
            }
            
            // 구별 필터 접기/펼치기 기능
            var districtFilterHeader = document.getElementById('district-filter-header');
            var districtFilters = document.getElementById('district-filters');
            if (districtFilterHeader && districtFilters) {
                districtFilterHeader.addEventListener('click', function(e) {
                    e.stopPropagation();
                    var isCollapsed = districtFilters.style.display === 'none';
                    var toggleIcon = districtFilterHeader.querySelector('.district-toggle-icon');
                    
                    if (isCollapsed) {
                        districtFilters.style.display = 'block';
                        if (toggleIcon) toggleIcon.textContent = '▼';
                    } else {
                        districtFilters.style.display = 'none';
                        if (toggleIcon) toggleIcon.textContent = '▶';
                    }
                });
            }
            
            // 패널 토글 버튼 이벤트 리스너 (중복 방지)
            var togglePanel = document.getElementById('toggle-panel');
            var newTogglePanel = togglePanel.cloneNode(true);
            togglePanel.parentNode.replaceChild(newTogglePanel, togglePanel);
            newTogglePanel.addEventListener('click', function(e) {
                e.stopPropagation(); // 드래그 이벤트와 충돌 방지
                var panel = document.getElementById('options-panel');
                var content = document.querySelector('.options-content');
                var btn = this;
                
                if (panel.classList.contains('collapsed')) {
                    panel.classList.remove('collapsed');
                    content.style.display = 'block';
                    btn.textContent = '−';
                } else {
                    panel.classList.add('collapsed');
                    content.style.display = 'none';
                    btn.textContent = '+';
                }
            });
            
            // 패널 드래그 기능 추가
            var panel = document.getElementById('options-panel');
            var panelHeader = document.getElementById('panel-header');
            var isDragging = false;
            var currentX;
            var currentY;
            var initialX;
            var initialY;
            var xOffset = 0;
            var yOffset = 0;
            
            // 드래그 시작 시 left로 전환
            var isDraggable = false;
            
            function setInitialPosition() {
                // 패널이 아직 렌더링되지 않았을 수 있으므로 약간의 지연
                setTimeout(function() {
                    if (!isDraggable) {
                        // 초기 상태: 오른쪽 끝에 고정 (CSS의 right: 0 사용)
                        panel.style.right = '0';
                        panel.style.left = 'auto';
                        yOffset = 20;
                    }
                }, 100);
            }
            setInitialPosition();
            
            // 창 크기 변경 시 위치 조정
            window.addEventListener('resize', function() {
                if (!isDragging) {
                    var currentLeft = parseInt(panel.style.left) || 0;
                    var maxX = window.innerWidth - panel.offsetWidth;
                    if (currentLeft > maxX) {
                        panel.style.left = Math.max(0, maxX) + 'px';
                        xOffset = parseInt(panel.style.left);
                    }
                }
            });
            
            panelHeader.addEventListener('mousedown', function(e) {
                if (e.target.id === 'toggle-panel') {
                    return; // 토글 버튼 클릭 시 드래그 방지
                }
                
                // 첫 드래그 시 left로 전환
                if (!isDraggable) {
                    isDraggable = true;
                    panel.classList.add('draggable');
                    var panelRect = panel.getBoundingClientRect();
                    xOffset = panelRect.left;
                    yOffset = panelRect.top;
                }
                
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;
                
                if (e.target === panelHeader || panelHeader.contains(e.target)) {
                    isDragging = true;
                    panelHeader.style.cursor = 'grabbing';
                }
            });
            
            document.addEventListener('mousemove', function(e) {
                if (isDragging) {
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    
                    // 화면 경계 내에서만 이동 가능
                    var maxX = window.innerWidth - panel.offsetWidth;
                    var maxY = window.innerHeight - panel.offsetHeight;
                    
                    currentX = Math.max(0, Math.min(currentX, maxX));
                    currentY = Math.max(0, Math.min(currentY, maxY));
                    
                    xOffset = currentX;
                    yOffset = currentY;
                    
                    panel.style.left = currentX + 'px';
                    panel.style.top = currentY + 'px';
                    panel.style.right = 'auto';
                }
            });
            
            document.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    panelHeader.style.cursor = 'grab';
                }
            });
            
            // 헤더에 grab 커서 표시
            panelHeader.style.cursor = 'grab';
            
            // 자전거 대여소 정보 기능 초기화
            initBikeStations();
            
            // 경로 찾기 기능 초기화
            initRouteControls();
            
            // 사용량 보기 체크박스 이벤트 리스너
            var showUsageCheckbox = document.getElementById('show-usage-view');
            if (showUsageCheckbox) {
                showUsageCheckbox.addEventListener('change', function() {
                    updateMarkerColors();
                });
            }
        }
        
        // 자전거 대여소 정보 기능 초기화
        function initBikeStations() {
            // 페이지 로드 시 즉시 데이터를 미리 로드 (지역 선택 시 빠른 반응을 위해)
            loadBikeStations();
            
            var clearBtn = document.getElementById('clear-bike-stations');
            if (clearBtn) {
                clearBtn.addEventListener('click', function() {
                    clearBikeStationMarkers();
                    clearBtn.style.display = 'none';
                });
            }
        }
        
        // 자전거 대여소 정보 로드 (최적화: 첫 호출 제거하고 바로 3개 병렬 호출)
        function loadBikeStations() {
            // 데이터가 이미 로드 중이거나 로드 완료되었으면 중복 호출 방지
            if (isDataLoaded) {
                return;
            }
            
            // 바로 3회로 나누어 병렬 호출 (첫 호출 제거로 시간 단축)
            var calls = [
                { start: 1, end: 1000 },
                { start: 1001, end: 2000 },
                { start: 2001, end: 2540 }
            ];
            
            var responseKey = null; // 첫 번째 응답에서 결정
            
            // 모든 호출을 병렬로 실행
            var fetchPromises = calls.map(function(call, index) {
                var pageApiUrl = getApiUrl('/json/bikeList/' + call.start + '/' + call.end + '/');
                
                return fetchWithRetry(pageApiUrl, 1, 300, '/json/bikeList/' + call.start + '/' + call.end + '/')
                    .then(function(pageData) {
                        // 응답 구조 확인 (첫 번째 호출에서만)
                        if (!responseKey) {
                            if (pageData.bikeList && pageData.bikeList.list_total_count) {
                                responseKey = 'bikeList';
                            } else {
                                for (var key in pageData) {
                                    if (pageData[key] && pageData[key].list_total_count) {
                                        responseKey = key;
                                        break;
                                    }
                                }
                            }
                        }
                        
                        // 응답 구조에 따라 데이터 추출
                        var rows = [];
                        if (pageData[responseKey] && pageData[responseKey].row) {
                            rows = Array.isArray(pageData[responseKey].row) ? 
                                   pageData[responseKey].row : 
                                   [pageData[responseKey].row];
                        }
                        return rows;
                    })
                    .catch(function(error) {
                        var errorMsg = error.message || error.toString();
                        if (errorMsg.includes('Failed to fetch') || errorMsg.includes('NetworkError')) {
                            console.error((index + 1) + '회 호출 실패: 네트워크 오류');
                        } else {
                            console.error((index + 1) + '회 호출 실패:', errorMsg);
                        }
                        return [];
                    });
            });
            
            // 모든 페이지 데이터를 기다린 후 합치기
            Promise.all(fetchPromises)
                .then(function(allPagesData) {
                    // 모든 페이지의 데이터를 하나로 합치기
                    var allRows = [];
                    if (allPagesData && allPagesData.length > 0) {
                        allPagesData.forEach(function(pageRows) {
                            if (pageRows && pageRows.length > 0) {
                                allRows = allRows.concat(pageRows);
                            }
                        });
                    }
                    
                    // 모든 데이터 저장 (지역 선택 시에만 표시)
                    allBikeStationData = allRows;
                    isDataLoaded = true; // 데이터 로드 완료 표시
                    
                    // 데이터 로드 완료 후 지역 필터가 선택되어 있으면 마커 표시
                    var hasSelectedDistrict = false;
                    document.querySelectorAll('.district-filter').forEach(function(checkbox) {
                        if (checkbox.checked) {
                            hasSelectedDistrict = true;
                        }
                    });
                    
                    // 데이터 로드 완료 후 선택된 지역이 있으면 자동으로 마커 표시
                    if (hasSelectedDistrict) {
                        updateBikeStationMarkers();
                    }
                    
                    // 버튼 상태 업데이트
                    var clearBtn = document.getElementById('clear-bike-stations');
                    if (clearBtn) {
                        clearBtn.style.display = 'block';
                    }
                })
                .catch(function(error) {
                    var errorMsg = error.message || error.toString();
                    if (errorMsg.includes('Failed to fetch') || errorMsg.includes('NetworkError')) {
                        console.error('자전거 대여소 정보 API 호출 실패: 네트워크 오류 또는 CORS 문제');
                        alert('API 서버에 연결할 수 없습니다.\n\n가능한 원인:\n1. 인터넷 연결을 확인하세요\n2. API 서버 상태를 확인하세요\n3. 브라우저 콘솔에서 자세한 오류를 확인하세요');
                    } else {
                        console.error('자전거 대여소 정보 API 호출 실패:', errorMsg);
                        alert('데이터를 불러오는 중 오류가 발생했습니다: ' + errorMsg);
                    }
                });
        }
        
        // 자전거 대여소 마커 업데이트 (지역 필터 적용)
        function updateBikeStationMarkers() {
            // 선택된 지역 필터 가져오기
            var visibleDistricts = [];
            document.querySelectorAll('.district-filter').forEach(function(checkbox) {
                if (checkbox.checked) {
                    visibleDistricts.push(checkbox.dataset.district);
                }
            });
            
            // 지역이 선택되지 않았으면 모든 마커 제거
            if (visibleDistricts.length === 0) {
                clearBikeStationMarkers();
                return;
            }
            
            // 데이터가 이미 로드되어 있으면 즉시 필터링 (API 호출 없음)
            if (isDataLoaded && allBikeStationData.length > 0) {
                var cacheKey = visibleDistricts.slice().sort().join(',');
                if (bikeStationCache[cacheKey]) {
                    clearBikeStationMarkers();
                    displayFilteredBikeStationMarkers(bikeStationCache[cacheKey]);
                    return;
                }
                // 캐시에 없으면 필터링만 수행
                var filtered = filterBikeStationsByDistricts(allBikeStationData, visibleDistricts);
                bikeStationCache[cacheKey] = filtered;
                clearBikeStationMarkers();
                displayFilteredBikeStationMarkers(filtered);
                return;
            }
            
            // 데이터가 아직 로드되지 않았으면 로드 중... (백그라운드에서 로드)
            // loadBikeStations가 완료되면 자동으로 updateBikeStationMarkers가 호출됨
            if (!isDataLoaded) {
                // 데이터 로드 중이면 로드 완료를 기다림
                var checkInterval = setInterval(function() {
                    if (isDataLoaded) {
                        clearInterval(checkInterval);
                        // 데이터 로드 완료 후 필터링
                        var cacheKey = visibleDistricts.slice().sort().join(',');
                        if (bikeStationCache[cacheKey]) {
                            clearBikeStationMarkers();
                            displayFilteredBikeStationMarkers(bikeStationCache[cacheKey]);
                        } else {
                            var filtered = filterBikeStationsByDistricts(allBikeStationData, visibleDistricts);
                            bikeStationCache[cacheKey] = filtered;
                            clearBikeStationMarkers();
                            displayFilteredBikeStationMarkers(filtered);
                        }
                    }
                }, 100); // 100ms마다 확인
                return;
            }
            
            // 데이터가 이미 로드되어 있으면 즉시 필터링 (위에서 이미 처리됨)
        }
        
        // 지역별로 API 호출 및 필터링 (데이터가 없을 때만 호출)
        function loadAndFilterBikeStations(visibleDistricts) {
            // 데이터가 이미 로드되어 있으면 필터링만 수행 (이미 updateBikeStationMarkers에서 처리됨)
            if (isDataLoaded && allBikeStationData.length > 0) {
                var cacheKey = visibleDistricts.slice().sort().join(',');
                if (bikeStationCache[cacheKey]) {
                    clearBikeStationMarkers();
                    displayFilteredBikeStationMarkers(bikeStationCache[cacheKey]);
                    return;
                }
                var filtered = filterBikeStationsByDistricts(allBikeStationData, visibleDistricts);
                bikeStationCache[cacheKey] = filtered;
                clearBikeStationMarkers();
                displayFilteredBikeStationMarkers(filtered);
                return;
            }
            
            // 데이터가 없을 때만 API 호출 (3회로 나누어 호출)
            var calls = [
                { start: 1, end: 1000 },
                { start: 1001, end: 2000 },
                { start: 2001, end: 2540 }
            ];
            
            var allFilteredRows = [];
            var responseKey = null;
            
            // 각 호출을 순차적으로 실행하고 필터링
            var fetchPromises = calls.map(function(call, index) {
                var pageApiUrl = getApiUrl('/json/bikeList/' + call.start + '/' + call.end + '/');
                
                // 로그 최소화로 성능 향상
                return fetchWithRetry(pageApiUrl, 1, 300, '/json/bikeList/' + call.start + '/' + call.end + '/')
                    .then(function(pageData) {
                        // 응답 구조 확인 (첫 번째 호출에서만)
                        if (!responseKey) {
                            if (pageData.bikeList && pageData.bikeList.list_total_count) {
                                responseKey = 'bikeList';
                            } else {
                                for (var key in pageData) {
                                    if (pageData[key] && pageData[key].list_total_count) {
                                        responseKey = key;
                                        break;
                                    }
                                }
                            }
                        }
                        
                        // 응답 구조에 따라 데이터 추출
                        var rows = [];
                        if (pageData[responseKey] && pageData[responseKey].row) {
                            rows = Array.isArray(pageData[responseKey].row) ? 
                                   pageData[responseKey].row : 
                                   [pageData[responseKey].row];
                        }
                        
                        // 즉시 필터링 수행 (로그 제거로 성능 향상)
                        var filtered = filterBikeStationsByDistricts(rows, visibleDistricts);
                        
                        return filtered;
                    })
                    .catch(function(error) {
                        var errorMsg = error.message || error.toString();
                        if (errorMsg.includes('Failed to fetch') || errorMsg.includes('NetworkError')) {
                            console.error((index + 1) + '회 호출 실패: 네트워크 오류 또는 CORS 문제. API 서버에 연결할 수 없습니다.');
                            console.error('가능한 원인: 1) 인터넷 연결 확인 2) API 서버 상태 확인 3) CORS 정책 확인');
                        } else {
                            console.error((index + 1) + '회 호출 실패:', errorMsg);
                        }
                        return [];
                    });
            });
            
            // 모든 호출 완료 후 결과 합치기
            Promise.all(fetchPromises)
                .then(function(allFilteredResults) {
                    // 모든 필터링된 결과 합치기
                    allFilteredResults.forEach(function(filteredRows) {
                        if (filteredRows && filteredRows.length > 0) {
                            allFilteredRows = allFilteredRows.concat(filteredRows);
                        }
                    });
                    
                    // 캐시에 저장 (로그 제거로 성능 향상)
                    bikeStationCache[cacheKey] = allFilteredRows;
                    
                    // 새 데이터가 준비된 후에만 기존 마커 제거하고 새 마커 표시
                    // 이렇게 하면 마커가 사라졌다 나타나는 현상을 방지
                    clearBikeStationMarkers();
                    
                    if (allFilteredRows.length > 0) {
                        displayFilteredBikeStationMarkers(allFilteredRows);
                    } else {
                        console.log('선택된 지역에 해당하는 대여소가 없습니다.');
                    }
                })
                .catch(function(error) {
                    console.error('대여소 로드 및 필터링 실패:', error);
                    // 에러 발생 시에도 기존 마커는 유지
                });
        }
        
        // 대여소 데이터를 지역별로 필터링 (위도/경도 기반, 최적화)
        function filterBikeStationsByDistricts(rows, visibleDistricts) {
            if (!rows || rows.length === 0 || !visibleDistricts || visibleDistricts.length === 0) {
                return [];
            }
            
            // Turf.js 사용 가능 여부 확인
            if (typeof turf === 'undefined' || !turf.booleanPointInPolygon) {
                return [];
            }
            
            var filteredRows = [];
            
            // 선택된 지역의 GeoJSON feature 가져오기
            var selectedDistrictFeatures = [];
            visibleDistricts.forEach(function(districtName) {
                if (districtFeatures[districtName]) {
                    selectedDistrictFeatures.push(districtFeatures[districtName]);
                }
            });
            
            if (selectedDistrictFeatures.length === 0) {
                return [];
            }
            
            var filteredRows = [];
            
            // 최적화: for 루프 사용 (forEach보다 빠름)
            for (var idx = 0; idx < rows.length; idx++) {
                var row = rows[idx];
                // 좌표 추출
                var lat = parseFloat(row.lat || row.LAT || row.stationLatitude || row.latitude);
                var lng = parseFloat(row.lng || row.LNG || row.stationLongitude || row.longitude);
                
                // 유효한 좌표인지 확인
                if (!lat || !lng || isNaN(lat) || isNaN(lng) || 
                    lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                    continue; // 유효하지 않은 좌표는 제외
                }
                
                // 대여소 위치를 Turf Point로 생성 (GeoJSON 형식: [경도, 위도])
                var stationPoint = turf.point([lng, lat]);
                
                // 선택된 지역 중 하나라도 포함되면 매칭 (최적화: break 즉시 사용)
                for (var i = 0; i < selectedDistrictFeatures.length; i++) {
                    try {
                        if (turf.booleanPointInPolygon(stationPoint, selectedDistrictFeatures[i])) {
                            filteredRows.push(row);
                            break; // 매칭되면 즉시 종료
                        }
                    } catch (error) {
                        // 에러는 무시하고 계속 진행
                    }
                }
            }
            
            // 로그 제거로 성능 향상
            return filteredRows;
        }
        
        // 필터링된 대여소 마커 표시 (최적화)
        function displayFilteredBikeStationMarkers(filteredRows) {
            if (!filteredRows || filteredRows.length === 0) {
                return;
            }
            
            // 기존 마커는 이미 clearBikeStationMarkers()에서 제거되었으므로 여기서는 제거하지 않음
            
            // 마커 그룹 생성 (클러스터링 사용)
            bikeStationMarkerGroup = L.markerClusterGroup({
                showCoverageOnHover: false,
                maxClusterRadius: 80,
                spiderfyOnMaxZoom: false,
                disableClusteringAtZoom: 17,
                removeOutsideVisibleBounds: false,
                iconCreateFunction: function(cluster) {
                    var count = cluster.getChildCount();
                    var sizeClass = 'cluster-small';
                    if (count >= 50) {
                        sizeClass = 'cluster-large';
                    } else if (count >= 20) {
                        sizeClass = 'cluster-medium';
                    }
                    return L.divIcon({
                        html: '<div class="bike-cluster ' + sizeClass + '" style="background: #0066cc;"><span>' + count + '</span></div>',
                        className: '',
                        iconSize: [48, 48],
                        iconAnchor: [24, 24]
                    });
                }
            });
            
            // 각 대여소에 마커 추가
            filteredRows.forEach(function(row) {
                // 좌표 확인 (API 응답 구조에 따라 필드명이 다를 수 있음)
                var lat = parseFloat(row.lat || row.LAT || row.stationLatitude || row.latitude);
                var lng = parseFloat(row.lng || row.LNG || row.stationLongitude || row.longitude);
                
                // 유효한 좌표인지 확인
                if (lat && lng && !isNaN(lat) && !isNaN(lng) && 
                    lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
                    
                    // 대여소 이름
                    var stationName = row.stationName || row.STATION_NAME || row.name || '자전거 대여소';
                    
                    // 거치율 계산
                    var parkingBikeCnt = parseFloat(row.parkingBikeTotCnt || row.PARKING_BIKE_TOT_CNT || row.parkingBikeTotalCnt || 0);
                    var rackTotCnt = parseFloat(row.rackTotCnt || row.RACK_TOT_CNT || row.rackTotalCnt || 1);
                    var usageRate = rackTotCnt > 0 ? (parkingBikeCnt / rackTotCnt) * 100 : 0;
                    
                    // 마커 아이콘 생성 (기본 스타일 유지)
                    var apiMarkerIcon = L.divIcon({
                        className: '',
                        html: '<div class="bike-marker" style="filter: hue-rotate(200deg);"><div class="bike-marker__inner"></div></div>',
                        iconSize: [34, 44],
                        iconAnchor: [17, 42],
                        popupAnchor: [0, -36],
                        tooltipAnchor: [0, -30]
                    });
                    
                    // 마커에 거치율 정보 저장 (나중에 색상 업데이트용)
                    var markerData = {
                        usageRate: usageRate,
                        parkingBikeCnt: parkingBikeCnt,
                        rackTotCnt: rackTotCnt
                    };
                    
                    // 지역 정보 추출 및 저장
                    var district = row.SIGNGU_NM || row.sigunguNm || row.district || row.gu || 
                                  row.stationGrpName || row.구 || row.시군구 || '기타';
                    
                    // 마커 생성 (지역 정보 포함)
                    var marker = L.marker([lat, lng], { 
                        icon: apiMarkerIcon,
                        district: district,
                        stationData: row,
                        markerData: markerData // 거치율 정보 저장
                    })
                    .bindTooltip(stationName, {
                                permanent: false,
                                direction: 'top',
                                className: 'custom-tooltip',
                                offset: [0, -10]
                    })
                    // 마커 클릭 시 패널에 정보 표시 및 길찾기 기능
                    .on('click', function(e) {
                        e.originalEvent.stopPropagation();
                        // 패널에 정보 표시
                        showStationInfo(stationName, row);
                        
                        // 길찾기 기능: 출발지/도착지 설정
                        // 팝업 버튼 클릭과 구분하기 위해 약간의 지연
                        setTimeout(function() {
                            var markerLat = marker.getLatLng().lat;
                            var markerLng = marker.getLatLng().lng;
                            var markerName = stationName;
                            var markerDistrict = district;
                            
                            // 출발지와 도착지가 모두 설정되어 있으면 기존 경로 초기화
                            if (startLocation && endLocation) {
                                clearRoute();
                            }
                            
                            // 출발지가 없으면 출발지로 설정
                            if (!startLocation) {
                                setStartLocation(markerLat, markerLng, markerName, markerDistrict);
                            }
                            // 출발지가 있고 도착지가 없으면 도착지로 설정
                            else if (!endLocation) {
                                setEndLocation(markerLat, markerLng, markerName, markerDistrict);
                            }
                        }, 50);
                    });
                    
                    bikeStationMarkers.push(marker);
                    bikeStationMarkerGroup.addLayer(marker);
                    
                    // 마커 주변 색상 영역 생성 (사용량 보기용)
                    // 마커 정보를 circle에 연결하기 위해 marker와 row 정보 전달
                    console.log('Creating circle for:', stationName, 'usageRate:', usageRate);
                    var circle = createUsageCircle(lat, lng, usageRate, marker, row, stationName);
                    if (circle) {
                        bikeStationCircles.push(circle);
                        console.log('Circle added to array:', stationName, 'total circles:', bikeStationCircles.length);
                    } else {
                        console.error('Failed to create circle for:', stationName);
                    }
                }
            });
            
            // 사용량 보기 체크 여부 확인
            var showUsageView = document.getElementById('show-usage-view') && document.getElementById('show-usage-view').checked;
            
            // 마커 그룹을 지도에 추가 (사용량 보기가 체크되어 있지 않을 때만)
            if (bikeStationMarkerGroup) {
                if (!showUsageView) {
                    // 사용량 보기가 체크되어 있지 않으면 마커 표시
                    if (!map.hasLayer(bikeStationMarkerGroup)) {
                        map.addLayer(bikeStationMarkerGroup);
                    }
                    // 색상 영역은 숨김
                    bikeStationCircles.forEach(function(circle) {
                        if (map.hasLayer(circle)) {
                            map.removeLayer(circle);
                        }
                    });
                } else {
                    // 사용량 보기가 체크되어 있으면 마커는 숨기고 색상 영역만 표시
                    if (map.hasLayer(bikeStationMarkerGroup)) {
                        map.removeLayer(bikeStationMarkerGroup);
                    }
                    bikeStationCircles.forEach(function(circle) {
                        if (!map.hasLayer(circle)) {
                            circle.addTo(map);
                            // circle이 지도에 추가되었는지 확인
                            console.log('Circle added to map:', circle.stationName, 'hasLayer:', map.hasLayer(circle));
                        }
                    });
                }
            }
            
            console.log('자전거 대여소 마커 표시 완료:', bikeStationMarkers.length, '개');
        }
        
        // 거치율에 따른 색상 영역 생성
        function createUsageCircle(lat, lng, usageRate, marker, row, stationName) {
            console.log('createUsageCircle called:', stationName, lat, lng, usageRate);
            // 거치율에 따라 색상 결정
            var usageLevel = Math.floor(usageRate / 10); // 0~10 사이의 값
            var opacity = 0.2 + (usageLevel * 0.08); // 0.2 ~ 1.0 사이 (10단위당 0.08 증가)
            
            // 거치율에 따라 색상 변경 (높을수록 빨간색, 낮을수록 초록색)
            var r, g, b;
            if (usageRate >= 50) {
                // 높은 거치율 (50% 이상): 빨간색 계열
                var intensity = (usageRate - 50) / 50; // 0~1 사이
                r = 255;
                g = Math.floor(255 * (1 - intensity));
                b = Math.floor(255 * (1 - intensity));
            } else {
                // 낮은 거치율 (50% 미만): 초록색 계열
                var intensity = usageRate / 50; // 0~1 사이
                r = Math.floor(255 * intensity);
                g = 255;
                b = Math.floor(255 * intensity);
            }
            
            // 임의의 크기 (거치율에 따라 약간 변동)
            var baseRadius = 30 + (usageLevel * 5); // 기본 30m + 거치율에 따라 증가
            var randomVariation = Math.random() * 20 - 10; // -10 ~ +10 랜덤 변동
            var radius = baseRadius + randomVariation;
            
            // 원형 영역 생성 (interactive: true로 설정하여 마우스 이벤트 활성화)
            var circle = L.circle([lat, lng], {
                radius: radius,
                fillColor: 'rgb(' + r + ', ' + g + ', ' + b + ')',
                color: 'rgb(' + r + ', ' + g + ', ' + b + ')',
                weight: 2,
                opacity: opacity,
                fillOpacity: opacity * 0.5,
                interactive: true, // 마우스 이벤트 활성화
                bubblingMouseEvents: false // 이벤트 버블링 방지
            });
            
            // 마커 정보를 circle에 저장
            circle.marker = marker;
            circle.stationData = row;
            circle.stationName = stationName;
            circle.usageRate = usageRate;
            
            // 팝업 내용 생성
            var popupContent = generateStationPopupContent(stationName, row);
            
            // 팝업 인스턴스 저장 (circle에 직접 저장)
            circle._usagePopup = null;
            
            // 마우스 오버 시 팝업 표시
            circle.on('mouseover', function(e) {
                var circleLayer = this;
                // 기존 팝업이 있으면 제거
                if (circleLayer._usagePopup) {
                    map.closePopup(circleLayer._usagePopup);
                }
                
                // 새 팝업 생성 및 표시
                circleLayer._usagePopup = L.popup({
                    maxWidth: 350,
                    className: 'usage-circle-popup',
                    closeButton: false,
                    autoClose: false,
                    closeOnClick: false,
                    closeOnEscapeKey: false
                })
                .setLatLng([lat, lng])
                .setContent(popupContent);
                
                circleLayer._usagePopup.openOn(map);
            });
            
            // 마우스 아웃 시 팝업 제거
            circle.on('mouseout', function(e) {
                var circleLayer = this;
                if (circleLayer._usagePopup) {
                    map.closePopup(circleLayer._usagePopup);
                    circleLayer._usagePopup = null;
                }
            });
            
            // 클릭 이벤트는 막기 (팝업이 닫히지 않도록)
            circle.on('click', function(e) {
                e.originalEvent.stopPropagation();
            });
            
            // circle이 지도에 추가된 후에도 이벤트가 작동하도록 확인
            circle.on('add', function() {
                console.log('Circle added to map:', stationName);
            });
            
            return circle;
        }
        
        // 대여소 정보 팝업 내용 생성 (마커 팝업과 동일한 형식)
        function generateStationPopupContent(stationName, row) {
            var popupContent = '<div class="info">';
            popupContent += '<strong style="font-size: 16px; display: block; margin-bottom: 12px;">' + stationName + '</strong>';
            
            // 제외할 필드 목록
            var excludeFields = {
                'lat': true, 'LAT': true, 'stationLatitude': true, 'latitude': true,
                'lng': true, 'LNG': true, 'stationLongitude': true, 'longitude': true,
                'stationName': true, 'STATION_NAME': true, 'name': true,
                'rackTotCnt': true, 'RACK_TOT_CNT': true, 'rackTotalCnt': true,
                'parkingTotal': true, 'totalParking': true,
                'stationId': true, 'STATION_ID': true
            };
            
            // 모든 필드를 동적으로 표시
            var hasData = false;
            var fieldOrder = [];
            var fieldValues = {};
            
            for (var key in row) {
                if (row.hasOwnProperty(key) && !excludeFields[key]) {
                    var value = row[key];
                    if (value !== null && value !== undefined && value !== '') {
                        fieldOrder.push(key);
                        fieldValues[key] = value;
                        hasData = true;
                    }
                }
            }
            
            // 필드명을 한글이나 의미있는 이름으로 변환하는 함수
            function getFieldLabel(key) {
                if (/[가-힣]/.test(key)) {
                    return key;
                }
                
                var fieldMap = {
                    'parkingBikeTotCnt': '현재 자전거 수',
                    'PARKING_BIKE_TOT_CNT': '현재 자전거 수',
                    'parkingBikeTotalCnt': '현재 자전거 수',
                    'shared': '거치율',
                    'SHARED': '거치율',
                    'address': '주소',
                    'ADDRESS': '주소',
                    'district': '시군구',
                    'SIGNGU_NM': '시군구',
                    'gu': '구',
                    'stationLatitude': '위도',
                    'stationLongitude': '경도',
                    'stationName': '대여소명',
                    'STATION_NAME': '대여소명'
                };
                
                return fieldMap[key] || key;
            }
            
            // 값 포맷팅 함수
            function formatValue(key, value) {
                if (typeof value === 'number' || (!isNaN(value) && value !== '')) {
                    var numValue = parseFloat(value);
                    if (!isNaN(numValue)) {
                        if (numValue % 1 === 0) {
                            return numValue.toLocaleString();
                        }
                        return numValue.toLocaleString(undefined, { maximumFractionDigits: 2 });
                    }
                }
                return String(value);
            }
            
            // 필드를 표시
            if (hasData) {
                fieldOrder.forEach(function(key) {
                    var label = getFieldLabel(key);
                    var value = formatValue(key, fieldValues[key]);
                    
                    popupContent += '<div style="margin-bottom: 6px; padding-bottom: 6px; border-bottom: 1px solid #f0f0f0;">';
                    popupContent += '<span style="color: #666; font-size: 12px; display: inline-block; min-width: 100px;">' + label + ':</span> ';
                    popupContent += '<span style="color: #333; font-size: 13px; font-weight: 500;">' + value + '</span>';
                    popupContent += '</div>';
                });
            } else {
                popupContent += '<div style="color: #999; font-size: 12px;">추가 정보가 없습니다.</div>';
            }
            
            popupContent += '</div>';
            return popupContent;
        }
        
        // 사용량 보기 체크박스 변경 시 색상 영역 표시/숨김 및 마커 표시/숨김
        function updateMarkerColors() {
            var showUsageView = document.getElementById('show-usage-view') && document.getElementById('show-usage-view').checked;
            
            if (showUsageView) {
                // 사용량 보기 활성화: 마커 숨기고 색상 영역 표시
                if (bikeStationMarkerGroup && map.hasLayer(bikeStationMarkerGroup)) {
                    map.removeLayer(bikeStationMarkerGroup);
                }
                
                bikeStationCircles.forEach(function(circle) {
                    if (!map.hasLayer(circle)) {
                        circle.addTo(map);
                    }
                });
            } else {
                // 사용량 보기 비활성화: 색상 영역 숨기고 마커 표시
                bikeStationCircles.forEach(function(circle) {
                    if (map.hasLayer(circle)) {
                        map.removeLayer(circle);
                    }
                });
                
                if (bikeStationMarkerGroup && !map.hasLayer(bikeStationMarkerGroup)) {
                    map.addLayer(bikeStationMarkerGroup);
                }
            }
        }
        
        // 자전거 대여소 마커 제거
        function clearBikeStationMarkers() {
            if (bikeStationMarkerGroup) {
                map.removeLayer(bikeStationMarkerGroup);
                bikeStationMarkerGroup.clearLayers();
                bikeStationMarkerGroup = null;
            }
            bikeStationMarkers = [];
            
            // 색상 영역도 제거
            bikeStationCircles.forEach(function(circle) {
                if (map.hasLayer(circle)) {
                    map.removeLayer(circle);
                }
            });
            bikeStationCircles = [];
        }
        
        // 경로 찾기 기능 초기화
        function initRouteControls() {
            // 경로 초기화 버튼
            var clearBtn = document.getElementById('clear-route-btn');
            if (clearBtn) {
                clearBtn.addEventListener('click', function() {
                    clearRoute();
                });
            }
            
            // 우측 패널 닫기 버튼
            var closeBtn = document.getElementById('close-route-info');
            if (closeBtn) {
                closeBtn.addEventListener('click', function() {
                    // 경로 정보 패널을 닫을 때 지도에 표시된 경로도 함께 제거
                    clearRoute();
                });
            }
            
            // 대여소 정보 패널 닫기 버튼
            var closeStationBtn = document.getElementById('close-station-info');
            if (closeStationBtn) {
                closeStationBtn.addEventListener('click', function() {
                    hideStationInfo();
                });
            }
        }
        
        // 출발지 설정
        function setStartLocation(lat, lng, name, district) {
            startLocation = { lat: lat, lng: lng, name: name, district: district };
            updateRouteInfo();
            
            // 출발지 마커 표시
            if (startMarker) {
                map.removeLayer(startMarker);
            }
            startMarker = L.marker([lat, lng], {
                icon: L.divIcon({
                    className: 'route-marker route-start-marker',
                    html: '<div class="route-marker-inner">출발</div>',
                    iconSize: [60, 30],
                    iconAnchor: [30, 15]
                })
            }).addTo(map);
            
            // 도착지가 이미 설정되어 있으면 자동으로 경로 계산
            if (endLocation) {
                calculateRoute(startLocation, endLocation);
            }
        }
        
        // 도착지 설정
        function setEndLocation(lat, lng, name, district) {
            endLocation = { lat: lat, lng: lng, name: name, district: district };
            updateRouteInfo();
            
            // 도착지 마커 표시
            if (endMarker) {
                map.removeLayer(endMarker);
            }
            endMarker = L.marker([lat, lng], {
                icon: L.divIcon({
                    className: 'route-marker route-end-marker',
                    html: '<div class="route-marker-inner">도착</div>',
                    iconSize: [60, 30],
                    iconAnchor: [30, 15]
                })
            }).addTo(map);
            
            // 출발지가 이미 설정되어 있으면 자동으로 경로 계산
            if (startLocation) {
                calculateRoute(startLocation, endLocation);
            }
        }
        
        // 대여소 정보 패널에 정보 표시
        function showStationInfo(stationName, row) {
            var infoPanel = document.getElementById('station-info-panel');
            var infoContent = document.getElementById('station-info-content');
            
            if (!infoPanel || !infoContent) return;
            
            // 패널 내용 생성
            var content = '<div class="info">';
            content += '<strong style="font-size: 16px; display: block; margin-bottom: 12px;">' + stationName + '</strong>';
            
            // 제외할 필드 목록
            var excludeFields = {
                'lat': true, 'LAT': true, 'stationLatitude': true, 'latitude': true,
                'lng': true, 'LNG': true, 'stationLongitude': true, 'longitude': true,
                'stationName': true, 'STATION_NAME': true, 'name': true,
                'rackTotCnt': true, 'RACK_TOT_CNT': true, 'rackTotalCnt': true,
                'parkingTotal': true, 'totalParking': true,
                'stationId': true, 'STATION_ID': true
            };
            
            // 모든 필드를 동적으로 표시
            var hasData = false;
            var fieldOrder = [];
            var fieldValues = {};
            
            for (var key in row) {
                if (row.hasOwnProperty(key) && !excludeFields[key]) {
                    var value = row[key];
                    if (value !== null && value !== undefined && value !== '') {
                        fieldOrder.push(key);
                        fieldValues[key] = value;
                        hasData = true;
                    }
                }
            }
            
            // 필드명을 한글이나 의미있는 이름으로 변환하는 함수
            function getFieldLabel(key) {
                if (/[가-힣]/.test(key)) {
                    return key;
                }
                
                var fieldMap = {
                    'parkingBikeTotCnt': '현재 자전거 수',
                    'PARKING_BIKE_TOT_CNT': '현재 자전거 수',
                    'parkingBikeTotalCnt': '현재 자전거 수',
                    'shared': '거치율',
                    'SHARED': '거치율',
                    'address': '주소',
                    'ADDRESS': '주소',
                    'district': '시군구',
                    'SIGNGU_NM': '시군구',
                    'gu': '구',
                    'stationLatitude': '위도',
                    'stationLongitude': '경도',
                    'stationName': '대여소명',
                    'STATION_NAME': '대여소명'
                };
                
                return fieldMap[key] || key;
            }
            
            // 값 포맷팅 함수
            function formatValue(key, value) {
                if (typeof value === 'number' || (!isNaN(value) && value !== '')) {
                    var numValue = parseFloat(value);
                    if (!isNaN(numValue)) {
                        if (numValue % 1 === 0) {
                            return numValue.toLocaleString();
                        }
                        return numValue.toLocaleString(undefined, { maximumFractionDigits: 2 });
                    }
                }
                return String(value);
            }
            
            // 필드를 표시
            if (hasData) {
                fieldOrder.forEach(function(key) {
                    var label = getFieldLabel(key);
                    var value = formatValue(key, fieldValues[key]);
                    
                    content += '<div style="margin-bottom: 6px; padding-bottom: 6px; border-bottom: 1px solid #f0f0f0;">';
                    content += '<span style="color: #666; font-size: 12px; display: inline-block; min-width: 100px;">' + label + ':</span> ';
                    content += '<span style="color: #333; font-size: 13px; font-weight: 500;">' + value + '</span>';
                    content += '</div>';
                });
            } else {
                content += '<div style="color: #999; font-size: 12px;">추가 정보가 없습니다.</div>';
            }
            
            content += '</div>';
            
            // 패널 내용 업데이트 및 표시
            infoContent.innerHTML = content;
            infoPanel.classList.add('visible');
        }
        
        // 대여소 정보 패널 숨김
        function hideStationInfo() {
            var infoPanel = document.getElementById('station-info-panel');
            if (infoPanel) {
                infoPanel.classList.remove('visible');
            }
        }
        
        // 대여소 정보 패널에 정보 표시
        function showStationInfo(stationName, row) {
            var infoPanel = document.getElementById('station-info-panel');
            var infoContent = document.getElementById('station-info-content');
            
            if (!infoPanel || !infoContent) return;
            
            // 패널 내용 생성
            var content = '<div class="info">';
            content += '<strong style="font-size: 16px; display: block; margin-bottom: 12px;">' + stationName + '</strong>';
            
            // 제외할 필드 목록
            var excludeFields = {
                'lat': true, 'LAT': true, 'stationLatitude': true, 'latitude': true,
                'lng': true, 'LNG': true, 'stationLongitude': true, 'longitude': true,
                'stationName': true, 'STATION_NAME': true, 'name': true,
                'rackTotCnt': true, 'RACK_TOT_CNT': true, 'rackTotalCnt': true,
                'parkingTotal': true, 'totalParking': true,
                'stationId': true, 'STATION_ID': true
            };
            
            // 모든 필드를 동적으로 표시
            var hasData = false;
            var fieldOrder = [];
            var fieldValues = {};
            
            for (var key in row) {
                if (row.hasOwnProperty(key) && !excludeFields[key]) {
                    var value = row[key];
                    if (value !== null && value !== undefined && value !== '') {
                        fieldOrder.push(key);
                        fieldValues[key] = value;
                        hasData = true;
                    }
                }
            }
            
            // 필드명을 한글이나 의미있는 이름으로 변환하는 함수
            function getFieldLabel(key) {
                if (/[가-힣]/.test(key)) {
                    return key;
                }
                
                var fieldMap = {
                    'parkingBikeTotCnt': '현재 자전거 수',
                    'PARKING_BIKE_TOT_CNT': '현재 자전거 수',
                    'parkingBikeTotalCnt': '현재 자전거 수',
                    'shared': '거치율',
                    'SHARED': '거치율',
                    'address': '주소',
                    'ADDRESS': '주소',
                    'district': '시군구',
                    'SIGNGU_NM': '시군구',
                    'gu': '구',
                    'stationLatitude': '위도',
                    'stationLongitude': '경도',
                    'stationName': '대여소명',
                    'STATION_NAME': '대여소명'
                };
                
                return fieldMap[key] || key;
            }
            
            // 값 포맷팅 함수
            function formatValue(key, value) {
                if (typeof value === 'number' || (!isNaN(value) && value !== '')) {
                    var numValue = parseFloat(value);
                    if (!isNaN(numValue)) {
                        if (numValue % 1 === 0) {
                            return numValue.toLocaleString();
                        }
                        return numValue.toLocaleString(undefined, { maximumFractionDigits: 2 });
                    }
                }
                return String(value);
            }
            
            // 필드를 표시
            if (hasData) {
                fieldOrder.forEach(function(key) {
                    var label = getFieldLabel(key);
                    var value = formatValue(key, fieldValues[key]);
                    
                    content += '<div style="margin-bottom: 6px; padding-bottom: 6px; border-bottom: 1px solid #f0f0f0;">';
                    content += '<span style="color: #666; font-size: 12px; display: inline-block; min-width: 100px;">' + label + ':</span> ';
                    content += '<span style="color: #333; font-size: 13px; font-weight: 500;">' + value + '</span>';
                    content += '</div>';
                });
            } else {
                content += '<div style="color: #999; font-size: 12px;">추가 정보가 없습니다.</div>';
            }
            
            content += '</div>';
            
            // 패널 내용 업데이트 및 표시
            infoContent.innerHTML = content;
            infoPanel.classList.add('visible');
        }
        
        // 대여소 정보 패널 숨김
        function hideStationInfo() {
            var infoPanel = document.getElementById('station-info-panel');
            if (infoPanel) {
                infoPanel.classList.remove('visible');
            }
        }
        
        // 경로 정보 업데이트
        function updateRouteInfo() {
            var startInfo = document.getElementById('route-start-info');
            var endInfo = document.getElementById('route-end-info');
            
            if (startInfo) {
                startInfo.textContent = '출발지: ' + (startLocation ? startLocation.name : '미설정');
            }
            if (endInfo) {
                endInfo.textContent = '도착지: ' + (endLocation ? endLocation.name : '미설정');
            }
        }
        
        // 경로 계산 (OSRM API 사용)
        function calculateRoute(start, end) {
            var infoPanel = document.getElementById('route-info-panel');
            var infoContent = document.getElementById('route-info-content');
            
            // 우측 패널 표시
            if (infoPanel) {
                infoPanel.classList.add('visible');
            }
            
            // 로딩 메시지 표시
            if (infoContent) {
                infoContent.innerHTML = '<div class="route-info-loading">경로 계산 중...</div>';
            }
            
            // OSRM API 엔드포인트 (도보 경로)
            // OSRM의 foot 프로필은 도보 경로를 우선합니다
            var osrmUrl = 'https://router.project-osrm.org/route/v1/foot/' + 
                start.lng + ',' + start.lat + ';' + end.lng + ',' + end.lat + 
                '?overview=full&geometries=geojson&alternatives=false&steps=false';
            
            // GraphHopper API 사용 (선택사항 - API 키가 있는 경우)
            var useGraphHopper = typeof GRAPHHOPPER_API_KEY !== 'undefined' && 
                                 GRAPHHOPPER_API_KEY !== '' && 
                                 GRAPHHOPPER_API_KEY !== 'YOUR_API_KEY';
            
            var apiUrl;
            if (useGraphHopper) {
                // GraphHopper 도보 경로
                apiUrl = 'https://graphhopper.com/api/1/route?' +
                    'point=' + start.lat + ',' + start.lng +
                    '&point=' + end.lat + ',' + end.lng +
                    '&vehicle=foot' +
                    '&key=' + GRAPHHOPPER_API_KEY +
                    '&type=json' +
                    '&instructions=false' +
                    '&calc_points=true' +
                    '&points_encoded=false';
            } else {
                apiUrl = osrmUrl;
            }
            
            fetch(apiUrl)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('경로를 찾을 수 없습니다.');
                    }
                    return response.json();
                })
                .then(function(data) {
                    var route, geometry, distance, duration;
                    
                    if (useGraphHopper && data.paths && data.paths.length > 0) {
                        // GraphHopper 응답 처리 (도보 경로)
                        route = data.paths[0];
                        // GraphHopper는 points_encoded=false일 때 GeoJSON 형식으로 반환
                        var coords = route.points.coordinates || route.points;
                        geometry = {
                            type: 'LineString',
                            coordinates: coords.map(function(coord) {
                                // GraphHopper는 [lng, lat] 형식이므로 [lat, lng]로 변환
                                return [coord[1], coord[0]];
                            })
                        };
                        distance = (route.distance / 1000).toFixed(2); // km
                        duration = Math.round(route.time / 1000 / 60); // 초를 분으로 변환
                    } else if (!useGraphHopper && data.code === 'Ok' && data.routes && data.routes.length > 0) {
                        // OSRM 응답 처리
                        route = data.routes[0];
                        geometry = route.geometry;
                        distance = (route.distance / 1000).toFixed(2); // km
                        // 자전거 평균 속도로 시간 재계산 (약 15km/h)
                        // OSRM의 foot duration이 정확하지 않을 수 있으므로 거리 기반으로 계산
                        var bikeSpeedKmh = 15; // 자전거 평균 속도 (km/h)
                        var distanceKm = parseFloat(distance);
                        duration = Math.round((distanceKm / bikeSpeedKmh) * 60); // 분으로 변환
                    } else {
                        throw new Error('경로를 찾을 수 없습니다.');
                    }
                    
                    // 경로 표시
                    displayRoute(geometry, route);
                    
                    // 경로 정보 표시
                    if (infoContent) {
                        infoContent.innerHTML = 
                            '<div class="route-info-item">' +
                            '<div class="route-info-label">출발지</div>' +
                            '<div class="route-info-value">' + (start.name || '미설정') + '</div>' +
                            '</div>' +
                            '<div class="route-info-item">' +
                            '<div class="route-info-label">도착지</div>' +
                            '<div class="route-info-value">' + (end.name || '미설정') + '</div>' +
                            '</div>' +
                            '<div class="route-info-divider"></div>' +
                            '<div class="route-info-item">' +
                            '<div class="route-info-label">거리</div>' +
                            '<div class="route-info-value highlight">' + distance + ' km</div>' +
                            '</div>' +
                            '<div class="route-info-item">' +
                            '<div class="route-info-label">예상 시간</div>' +
                            '<div class="route-info-value highlight">' + duration + ' 분</div>' +
                            '</div>';
                    }
                })
                .catch(function(error) {
                    console.error('경로 계산 오류:', error);
                    if (infoContent) {
                        infoContent.innerHTML = '<div class="route-info-error">경로를 찾을 수 없습니다.</div>';
                    }
                });
        }
        
        // 경로 표시
        function displayRoute(geometry, route) {
            // 기존 경로 제거
            if (routeLayer) {
                map.removeLayer(routeLayer);
            }
            
            // GeoJSON 형식의 좌표를 Leaflet 형식으로 변환
            var latlngs = geometry.coordinates.map(function(coord) {
                return [coord[1], coord[0]]; // [lat, lng]
            });
            
            // 경로 polyline 생성
            routeLayer = L.polyline(latlngs, {
                color: '#ff6b6b', // 빨간색 계열로 변경
                weight: 5,
                opacity: 0.8,
                smoothFactor: 1
            }).addTo(map);
            
            // 경로에 맞게 지도 범위 조정
            var bounds = routeLayer.getBounds();
            map.fitBounds(bounds, { padding: [50, 50] });
        }
        
        // 경로 초기화
        function clearRoute() {
            // 경로 레이어 제거
            if (routeLayer) {
                map.removeLayer(routeLayer);
                routeLayer = null;
            }
            
            // 마커 제거
            if (startMarker) {
                map.removeLayer(startMarker);
                startMarker = null;
            }
            if (endMarker) {
                map.removeLayer(endMarker);
                endMarker = null;
            }
            
            // 위치 초기화
            startLocation = null;
            endLocation = null;
            
            // 정보 업데이트
            updateRouteInfo();
            
            // 우측 패널 숨기기
            var infoPanel = document.getElementById('route-info-panel');
            var infoContent = document.getElementById('route-info-content');
            if (infoPanel) {
                infoPanel.classList.remove('visible');
            }
            if (infoContent) {
                infoContent.innerHTML = '<div class="route-info-placeholder">경로를 계산하면 정보가 표시됩니다.</div>';
            }
        }
        
        // 마커 업데이트 (필터링)
        function updateMarkers() {
            // data.json 마커는 화면에서 숨김 (나중에 필요하면 다시 활성화 가능)
            console.log('updateMarkers called - data.json 마커는 현재 숨김 처리됨');
            return; // data.json 마커를 표시하지 않음
            
            // 아래 코드는 주석 처리 (나중에 필요하면 주석 해제)
            /*
            if (Object.keys(clusterGroupsByDistrict).length === 0) {
                console.warn('No cluster groups available');
                return;
            }
            
            var visibleDistricts = [];
            
            // 선택된 구 필터 수집
            document.querySelectorAll('.district-filter').forEach(function(checkbox) {
                if (checkbox.checked) {
                    visibleDistricts.push(checkbox.dataset.district);
                }
            });
            
            console.log('Visible districts:', visibleDistricts);
            console.log('Available cluster groups:', Object.keys(clusterGroupsByDistrict));
            console.log('Available markers by district:', Object.keys(markersByDistrict));
            
            // 먼저 모든 클러스터 그룹을 지도에서 제거하고 마커도 제거
            for (var district in clusterGroupsByDistrict) {
                if (clusterGroupsByDistrict.hasOwnProperty(district)) {
                    var clusterGroup = clusterGroupsByDistrict[district];
                    // 마커 먼저 제거
                    clusterGroup.clearLayers();
                    // 지도에서 레이어 제거
                    if (map.hasLayer(clusterGroup)) {
                        map.removeLayer(clusterGroup);
                        console.log('Removed cluster group from map for district:', district);
                    }
                }
            }
            
            // 출발지/도착지가 표시되는 구역에 있는지 확인
            var shouldClearRoute = false;
            if (startLocation && startLocation.district) {
                if (visibleDistricts.indexOf(startLocation.district) === -1) {
                    shouldClearRoute = true;
                }
            }
            if (endLocation && endLocation.district) {
                if (visibleDistricts.indexOf(endLocation.district) === -1) {
                    shouldClearRoute = true;
                }
            }
            
            // 출발지/도착지가 표시되지 않는 구역에 있으면 경로 초기화
            if (shouldClearRoute) {
                clearRoute();
            }
            
            // 선택된 구의 클러스터 그룹만 다시 추가
            visibleDistricts.forEach(function(district) {
                if (clusterGroupsByDistrict[district] && markersByDistrict[district] && markersByDistrict[district].length > 0) {
                    var clusterGroup = clusterGroupsByDistrict[district];
                    console.log('Processing district:', district, 'marker count:', markersByDistrict[district].length);
                    
                    // 클러스터 그룹이 지도에 있는지 확인하고 없으면 추가
                    if (!map.hasLayer(clusterGroup)) {
                        map.addLayer(clusterGroup);
                        console.log('Cluster group added to map for district:', district);
                    }
                    
                    // 마커 추가
                    try {
                        clusterGroup.addLayers(markersByDistrict[district]);
                        console.log('Markers added to cluster group for district:', district);
                        
                        // 잠시 후 마커가 제대로 추가되었는지 확인
                        setTimeout(function() {
                            var addedLayers = clusterGroup.getLayers();
                            console.log('Layers in cluster group for', district, ':', addedLayers.length);
                            if (addedLayers.length === 0) {
                                console.error('WARNING: No layers in cluster group for district:', district);
                                // 다시 시도
                                clusterGroup.addLayers(markersByDistrict[district]);
                            }
                        }, 200);
                    } catch (error) {
                        console.error('Error adding markers for district:', district, error);
                    }
                } else {
                    console.warn('Cannot add markers for district:', district, 
                        'clusterGroup exists:', !!clusterGroupsByDistrict[district],
                        'markers exist:', !!(markersByDistrict[district] && markersByDistrict[district].length > 0));
                }
            });
            
            // 자전거 대여소 마커도 업데이트
            if (allBikeStationData && allBikeStationData.length > 0) {
                updateBikeStationMarkers();
            }
            */
        }
        
        // 클릭한 위치에서 가장 가까운 마커 찾기
        function findNearestMarker(clickLat, clickLng) {
            if (!allMarkers || allMarkers.length === 0) {
                return null;
            }
            
            var nearestMarker = null;
            var minDistance = Infinity;
            
            allMarkers.forEach(function(marker) {
                var markerLat = marker.getLatLng().lat;
                var markerLng = marker.getLatLng().lng;
                
                // 두 점 사이의 거리 계산 (하버사인 공식)
                var R = 6371; // 지구 반지름 (km)
                var dLat = (markerLat - clickLat) * Math.PI / 180;
                var dLng = (markerLng - clickLng) * Math.PI / 180;
                var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                        Math.cos(clickLat * Math.PI / 180) * Math.cos(markerLat * Math.PI / 180) *
                        Math.sin(dLng / 2) * Math.sin(dLng / 2);
                var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                var distance = R * c;
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestMarker = marker;
                }
            });
            
            // 5km 이내의 마커만 반환 (너무 멀면 무시)
            if (minDistance <= 5) {
                return nearestMarker;
            }
            return null;
        }
        
        // 구 필터 체크
        function checkDistrictFilter(districtName) {
            var checkboxes = document.querySelectorAll('.district-filter');
            checkboxes.forEach(function(checkbox) {
                if (checkbox.dataset.district === districtName) {
                    checkbox.checked = true;
                    updateMarkers();
                }
            });
        }
        
        // 구 필터 토글 (체크되어 있으면 해제, 없으면 체크)
        function toggleDistrictFilter(districtName) {
            console.log('toggleDistrictFilter called for:', districtName);
            var checkboxes = document.querySelectorAll('.district-filter');
            var found = false;
            var targetCheckbox = null;
            
            checkboxes.forEach(function(checkbox) {
                if (checkbox.dataset.district === districtName) {
                    found = true;
                    targetCheckbox = checkbox;
                    checkbox.checked = !checkbox.checked;
                    console.log('Checkbox toggled:', districtName, 'checked:', checkbox.checked);
                }
            });
            
            if (found && targetCheckbox) {
                // change 이벤트 수동 트리거
                var changeEvent = new Event('change');
                targetCheckbox.dispatchEvent(changeEvent);
            } else {
                console.warn('Checkbox not found for district:', districtName);
            }
        }
        
        // 구역 하이라이트
        function highlightDistrict(districtName) {
            if (!districtFeatures[districtName]) {
                return;
            }
            
            // 기존 하이라이트 제거
            clearDistrictHighlight();
            
            // 새 하이라이트 추가
            hoverHighlightLayer = L.geoJSON(districtFeatures[districtName], {
                style: {
                    color: '#4CAF50',
                    weight: 3,
                    opacity: 0.9,
                    fillOpacity: 0,
                    fillColor: '#4CAF50'
                }
            }).addTo(map);
        }
        
        // 구역 하이라이트 제거
        function clearDistrictHighlight() {
            if (hoverHighlightLayer) {
                map.removeLayer(hoverHighlightLayer);
                hoverHighlightLayer = null;
            }
        }
        
        // 클릭한 위치가 속한 구역 찾기
        function findDistrictAtPoint(lat, lng) {
            if (typeof turf === 'undefined' || !turf.booleanPointInPolygon) {
                // turf.js가 없으면 가장 가까운 마커 사용
                var nearestMarker = findNearestMarker(lat, lng);
                if (nearestMarker && nearestMarker.options.district) {
                    return nearestMarker.options.district;
                }
                return null;
            }
            
            var point = turf.point([lng, lat]);
            
            // 각 구역 feature를 확인
            for (var districtName in districtFeatures) {
                if (districtFeatures.hasOwnProperty(districtName)) {
                    var feature = districtFeatures[districtName];
                    try {
                        if (turf.booleanPointInPolygon(point, feature)) {
                            return districtName;
                        }
                    } catch (error) {
                        console.warn('구역 검사 중 오류:', error);
                    }
                }
            }
            
            // 구역을 찾지 못하면 가장 가까운 마커 사용
            var nearestMarker = findNearestMarker(lat, lng);
            if (nearestMarker && nearestMarker.options.district) {
                return nearestMarker.options.district;
            }
            
            return null;
        }
        
        // 지도 클릭 이벤트 설정 (경계 레이어 클릭 이벤트가 있으므로 비활성화)
        function initMapClickHandler() {
            // 경계 레이어의 클릭 이벤트를 사용하므로 지도 클릭 이벤트는 비활성화
            // 경계 레이어가 없는 영역을 클릭할 때만 작동하도록 함
            var mapClickHandler = function(e) {
                // 경계 레이어 클릭 이벤트가 이미 처리했는지 확인
                // 경계 레이어 클릭은 stopPropagation을 호출하므로 여기까지 오지 않음
                // 하지만 혹시 모를 경우를 대비해 경계 레이어가 없는 영역만 처리
                var clickLat = e.latlng.lat;
                var clickLng = e.latlng.lng;
                
                // 클릭한 위치가 속한 구역 찾기
                var district = findDistrictAtPoint(clickLat, clickLng);
                
                if (district) {
                    toggleDistrictFilter(district);
                }
            };
            
            // 지도 클릭 이벤트는 주석 처리 (경계 레이어 클릭만 사용)
            // map.on('click', mapClickHandler);
            
            // 지도에 마우스 오버 시 커서 변경
            map.getContainer().style.cursor = 'pointer';
        }
        // DOM이 준비된 후 옵션 패널 초기화
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                initOptionsPanel();
            });
        } else {
            // DOM이 이미 준비된 경우
            initOptionsPanel();
        }
    </script>
</body>
</html>

